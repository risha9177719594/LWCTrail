var WireService = (function (exports) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ValueChangedEventType = 'ValueChangedEvent';
    /**
     * Event fired by wire adapters to emit a new value.
     */
    var ValueChangedEvent = /** @class */ (function () {
        function ValueChangedEvent(value) {
            this.type = ValueChangedEventType;
            this.value = value;
        }
        return ValueChangedEvent;
    }());
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    function isUndefined(obj) {
        return obj === undefined;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    /** version: 1.6.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var freeze = Object.freeze, defineProperty = Object.defineProperty, isExtensible = Object.isExtensible; // This value needs to be in sync with wiring.ts from @lwc/engine
    var DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    /**
     * Registers a wire adapter factory for Lightning Platform.
     * @deprecated
     */
    function register(adapterId, adapterEventTargetCallback) {
        if (adapterId == null || !isExtensible(adapterId)) {
            throw new TypeError('adapter id must be extensible');
        }
        if (typeof adapterEventTargetCallback !== 'function') {
            throw new TypeError('adapter factory must be a callable');
        }
        if ('adapter' in adapterId) {
            throw new TypeError('adapter id is already associated to an adapter factory');
        }
        var AdapterClass = /** @class */ (function (_super) {
            __extends(AdapterClass, _super);
            function AdapterClass(dataCallback) {
                var _this = _super.call(this, dataCallback) || this;
                adapterEventTargetCallback(_this.eventTarget);
                return _this;
            }
            return AdapterClass;
        }(WireAdapter));
        freeze(AdapterClass);
        freeze(AdapterClass.prototype);
        defineProperty(adapterId, 'adapter', {
            writable: false,
            configurable: false,
            value: AdapterClass
        });
    }
    /**
     * Registers the wire service. noop
     * @deprecated
     */
    function registerWireService() { }
    var _a = Array.prototype, forEach = _a.forEach, ArraySplice = _a.splice, ArrayIndexOf = _a.indexOf; // wire event target life cycle connectedCallback hook event type
    var CONNECT = 'connect'; // wire event target life cycle disconnectedCallback hook event type
    var DISCONNECT = 'disconnect'; // wire event target life cycle config changed hook event type
    var CONFIG = 'config';
    function removeListener(listeners, toRemove) {
        var idx = ArrayIndexOf.call(listeners, toRemove);
        if (idx > -1) {
            ArraySplice.call(listeners, idx, 1);
        }
    }
    function isEmptyConfig(config) {
        return Object.keys(config).length === 0;
    }
    function isValidConfig(config) {
        return Object.keys(config).some(function (key) { return !isUndefined(config[key]); });
    }
    var WireAdapter = /** @class */ (function () {
        function WireAdapter(callback) {
            var _this = this;
            this.connecting = [];
            this.disconnecting = [];
            this.configuring = [];
            this.isFirstUpdate = true;
            this.callback = callback;
            this.wiredElementHost = callback[DeprecatedWiredElementHost];
            this.eventTarget = {
                addEventListener: function (type, listener) {
                    switch (type) {
                        case CONNECT:
                            {
                                _this.connecting.push(listener);
                                break;
                            }
                        case DISCONNECT:
                            {
                                _this.disconnecting.push(listener);
                                break;
                            }
                        case CONFIG:
                            {
                                _this.configuring.push(listener);
                                if (_this.currentConfig !== undefined) {
                                    listener.call(undefined, _this.currentConfig);
                                }
                                break;
                            }
                        default:
                            throw new Error("Invalid event type " + type + ".");
                    }
                },
                removeEventListener: function (type, listener) {
                    switch (type) {
                        case CONNECT:
                            {
                                removeListener(_this.connecting, listener);
                                break;
                            }
                        case DISCONNECT:
                            {
                                removeListener(_this.disconnecting, listener);
                                break;
                            }
                        case CONFIG:
                            {
                                removeListener(_this.configuring, listener);
                                break;
                            }
                        default:
                            throw new Error("Invalid event type " + type + ".");
                    }
                },
                dispatchEvent: function (evt) {
                    if (evt instanceof ValueChangedEvent) {
                        var value = evt.value;
                        _this.callback(value);
                    }
                    else if (evt.type === 'wirecontextevent') {
                        // TODO [#1357]: remove this branch
                        return _this.wiredElementHost.dispatchEvent(evt);
                    }
                    else {
                        throw new Error("Invalid event type " + evt.type + ".");
                    }
                    return false; // canceling signal since we don't want this to propagate
                }
            };
        }
        WireAdapter.prototype.update = function (config) {
            if (this.isFirstUpdate) {
                // this is a special case for legacy wire adapters: when all the config params are undefined,
                // the config on the wire adapter should not be called until one of them changes.
                this.isFirstUpdate = false; // Note: In the legacy adapters with static config, this check is not enforced, they always get called.
                // Ex: @wire(foo, { bar: undefined })
                // With this functionality, adapters with static and dynamic($) parameters will be treated the same.
                if (!isEmptyConfig(config) && !isValidConfig(config)) {
                    return;
                }
            }
            this.currentConfig = config;
            forEach.call(this.configuring, function (listener) {
                listener.call(undefined, config);
            });
        };
        WireAdapter.prototype.connect = function () {
            forEach.call(this.connecting, function (listener) { return listener.call(undefined); });
        };
        WireAdapter.prototype.disconnect = function () {
            forEach.call(this.disconnecting, function (listener) { return listener.call(undefined); });
        };
        return WireAdapter;
    }());
    /** version: 1.6.2 */

    exports.ValueChangedEvent = ValueChangedEvent;
    exports.WireAdapter = WireAdapter;
    exports.register = register;
    exports.registerWireService = registerWireService;

    return exports;

}({}));
