(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.LWC = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /* proxy-compat-disable */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect() {
        // Don't apply polyfill when ProxyCompat is enabled.
        if ('getKey' in Proxy) {
            return false;
        }
        var proxy = new Proxy([3, 4], {});
        var res = [1, 2].concat(proxy);
        return res.length !== 4;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isConcatSpreadable = Symbol.isConcatSpreadable;
    var isArray = Array.isArray;
    var _b = Array.prototype, ArraySlice = _b.slice, ArrayUnshift = _b.unshift, ArrayShift = _b.shift;
    function isObject(O) {
        return typeof O === 'object' ? O !== null : typeof O === 'function';
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
    function isSpreadable(O) {
        if (!isObject(O)) {
            return false;
        }
        var spreadable = O[isConcatSpreadable];
        return spreadable !== undefined ? Boolean(spreadable) : isArray(O);
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat
    function ArrayConcatPolyfill() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
        var O = Object(this);
        var A = [];
        var N = 0;
        var items = ArraySlice.call(arguments);
        ArrayUnshift.call(items, O);
        while (items.length) {
            var E = ArrayShift.call(items);
            if (isSpreadable(E)) {
                var k_1 = 0;
                var length = E.length;
                for (k_1; k_1 < length; k_1 += 1, N += 1) {
                    if (k_1 in E) {
                        var subElement = E[k_1];
                        A[N] = subElement;
                    }
                }
            }
            else {
                A[N] = E;
                N += 1;
            }
        }
        return A;
    }
    function apply() {
        Array.prototype.concat = ArrayConcatPolyfill;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect()) {
        apply();
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$1(propName) {
        return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var _c = Element.prototype, getAttribute = _c.getAttribute, hasAttribute = _c.hasAttribute, removeAttribute = _c.removeAttribute, setAttribute = _c.setAttribute;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`
    var ARIA_REGEX = /^aria/;
    var nodeToAriaPropertyValuesMap = new WeakMap();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var _d = String.prototype, StringReplace = _d.replace, StringToLowerCase = _d.toLowerCase;
    function getAriaPropertyMap(elm) {
        var map = nodeToAriaPropertyValuesMap.get(elm);
        if (map === undefined) {
            map = {};
            nodeToAriaPropertyValuesMap.set(elm, map);
        }
        return map;
    }
    function getNormalizedAriaPropertyValue(value) {
        return value == null ? null : value + '';
    }
    function createAriaPropertyPropertyDescriptor(propName, attrName) {
        return {
            get: function () {
                var map = getAriaPropertyMap(this);
                if (hasOwnProperty.call(map, propName)) {
                    return map[propName];
                } // otherwise just reflect what's in the attribute
                return hasAttribute.call(this, attrName) ? getAttribute.call(this, attrName) : null;
            },
            set: function (newValue) {
                var normalizedValue = getNormalizedAriaPropertyValue(newValue);
                var map = getAriaPropertyMap(this);
                map[propName] = normalizedValue; // reflect into the corresponding attribute
                if (newValue === null) {
                    removeAttribute.call(this, attrName);
                }
                else {
                    setAttribute.call(this, attrName, newValue);
                }
            },
            configurable: true,
            enumerable: true
        };
    }
    function patch(propName) {
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var replaced = StringReplace.call(propName, ARIA_REGEX, 'aria-');
        var attrName = StringToLowerCase.call(replaced);
        var descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);
        Object.defineProperty(Element.prototype, propName, descriptor);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // https://wicg.github.io/aom/spec/aria-reflection.html
    var ElementPrototypeAriaPropertyNames = ['ariaAutoComplete', 'ariaChecked', 'ariaCurrent', 'ariaDisabled', 'ariaExpanded', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaLabel', 'ariaLevel', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaPressed', 'ariaReadOnly', 'ariaRequired', 'ariaSelected', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'ariaLive', 'ariaRelevant', 'ariaAtomic', 'ariaBusy', 'ariaActiveDescendant', 'ariaControls', 'ariaDescribedBy', 'ariaFlowTo', 'ariaLabelledBy', 'ariaOwns', 'ariaPosInSet', 'ariaSetSize', 'ariaColCount', 'ariaColIndex', 'ariaDetails', 'ariaErrorMessage', 'ariaKeyShortcuts', 'ariaModal', 'ariaPlaceholder', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaColSpan', 'role'];
    /**
     * Note: Attributes aria-dropeffect and aria-grabbed were deprecated in
     * ARIA 1.1 and do not have corresponding IDL attributes.
     */
    for (var i_1 = 0, len = ElementPrototypeAriaPropertyNames.length; i_1 < len; i_1 += 1) {
        var propName = ElementPrototypeAriaPropertyNames[i_1];
        if (detect$1(propName)) {
            patch(propName);
        }
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant(value, msg) {
        if (!value) {
            throw new Error("Invariant Violation: " + msg);
        }
    }
    function isTrue(value, msg) {
        if (!value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function isFalse(value, msg) {
        if (value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function fail(msg) {
        throw new Error(msg);
    }
    var assert = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        invariant: invariant,
        isTrue: isTrue,
        isFalse: isFalse,
        fail: fail
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Global Aria and Role Properties derived from ARIA and Role Attributes.
    // https://wicg.github.io/aom/spec/aria-reflection.html
    var AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var assign = Object.assign, create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, freeze = Object.freeze, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getPrototypeOf = Object.getPrototypeOf, hasOwnProperty$1 = Object.hasOwnProperty, keys = Object.keys, seal = Object.seal, setPrototypeOf = Object.setPrototypeOf;
    var isArray$1 = Array.isArray;
    var _e = Array.prototype, ArrayIndexOf = _e.indexOf, ArrayJoin = _e.join, ArrayMap = _e.map, ArrayPush = _e.push, ArraySlice$1 = _e.slice, ArrayUnshift$1 = _e.unshift, forEach = _e.forEach;
    var _f = String.prototype, StringCharCodeAt = _f.charCodeAt, StringReplace$1 = _f.replace, StringSlice = _f.slice, StringToLowerCase$1 = _f.toLowerCase;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isTrue$1(obj) {
        return obj === true;
    }
    function isFalse$1(obj) {
        return obj === false;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isObject$1(obj) {
        return typeof obj === 'object';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    var OtS = {}.toString;
    function toString(obj) {
        if (obj && obj.toString) {
            // Arrays might hold objects with "null" prototype So using
            // Array.prototype.toString directly will cause an error Iterate through
            // all the items and handle individually.
            if (isArray$1(obj)) {
                return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS.call(obj);
        }
        else {
            return obj + emptyString;
        }
    }
    function getPropertyDescriptor(o, p) {
        do {
            var d_1 = getOwnPropertyDescriptor(o, p);
            if (!isUndefined(d_1)) {
                return d_1;
            }
            o = getPrototypeOf(o);
        } while (o !== null);
    }
    var emptyString = '';
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    function createHiddenField(key, namespace) {
        return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-" + namespace + "-" + key + "$$";
    }
    var hiddenFieldsMap = new WeakMap();
    function setHiddenField(o, field, value) {
        var valuesByField = hiddenFieldsMap.get(o);
        if (isUndefined(valuesByField)) {
            valuesByField = create(null);
            hiddenFieldsMap.set(o, valuesByField);
        }
        valuesByField[field] = value;
    }
    function getHiddenField(o, field) {
        var valuesByField = hiddenFieldsMap.get(o);
        if (!isUndefined(valuesByField)) {
            return valuesByField[field];
        }
    }
    /** version: 1.6.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var _g = Node.prototype, appendChild = _g.appendChild, insertBefore = _g.insertBefore, removeChild = _g.removeChild, replaceChild = _g.replaceChild;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getComponentTag(vm) {
        // Element.prototype.tagName getter might be poisoned. We need to use a try/catch to protect the
        // engine internal when accessing the tagName property.
        try {
            return "<" + StringToLowerCase$1.call(vm.elm.tagName) + ">";
        }
        catch (error) {
            return '<invalid-tag-name>';
        }
    } // TODO [#1695]: Unify getComponentStack and getErrorComponentStack
    function getErrorComponentStack(vm) {
        var wcStack = [];
        var currentVm = vm;
        while (!isNull(currentVm)) {
            ArrayPush.call(wcStack, getComponentTag(currentVm));
            currentVm = currentVm.owner;
        }
        return wcStack.reverse().join('\n\t');
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nextTickCallbackQueue = [];
    var SPACE_CHAR = 32;
    var EmptyObject = seal(create(null));
    var EmptyArray = seal([]);
    function flushCallbackQueue() {
        var callbacks = nextTickCallbackQueue;
        nextTickCallbackQueue = []; // reset to a new queue
        for (var i_2 = 0, len = callbacks.length; i_2 < len; i_2 += 1) {
            callbacks[i_2]();
        }
    }
    function addCallbackToNextTick(callback) {
        if (nextTickCallbackQueue.length === 0) {
            Promise.resolve().then(flushCallbackQueue);
        }
        ArrayPush.call(nextTickCallbackQueue, callback);
    }
    var useSyntheticShadow = hasOwnProperty$1.call(Element.prototype, '$shadowToken$');
    function guid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function handleEvent(event, vnode) {
        var type = event.type;
        var on = vnode.data.on;
        var handler = on && on[type]; // call event handler if exists
        if (handler) {
            handler.call(undefined, event);
        }
    }
    function createListener() {
        return function handler(event) {
            handleEvent(event, handler.vnode);
        };
    }
    function updateAllEventListeners(oldVnode, vnode) {
        if (isUndefined(oldVnode.listener)) {
            createAllEventListeners(vnode);
        }
        else {
            vnode.listener = oldVnode.listener;
            vnode.listener.vnode = vnode;
        }
    }
    function createAllEventListeners(vnode) {
        var on = vnode.data.on;
        if (isUndefined(on)) {
            return;
        }
        var elm = vnode.elm;
        var listener = vnode.listener = createListener();
        listener.vnode = vnode;
        var name;
        for (name in on) {
            elm.addEventListener(name, listener);
        }
    }
    var modEvents = {
        update: updateAllEventListeners,
        create: createAllEventListeners
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'spellcheck', 'tabIndex', 'title']; // Few more exceptions that are using the attribute name to match the property in lowercase.
    // this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx
    // and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
    // Note: this list most be in sync with the compiler as well.
    var HTMLPropertyNamesWithLowercasedReflectiveAttributes = ['accessKey', 'readOnly', 'tabIndex', 'bgColor', 'colSpan', 'rowSpan', 'contentEditable', 'dateTime', 'formAction', 'isMap', 'maxLength', 'useMap'];
    function offsetPropertyErrorMessage(name) {
        return "Using the `" + name + "` property is an anti-pattern because it rounds the value to an integer. Instead, use the `getBoundingClientRect` method to obtain fractional values for the size of an element and its position relative to the viewport.";
    } // Global HTML Attributes & Properties
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
    var globalHTMLProperties = assign(create(null), {
        accessKey: {
            attribute: 'accesskey'
        },
        accessKeyLabel: {
            readOnly: true
        },
        className: {
            attribute: 'class',
            error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'
        },
        contentEditable: {
            attribute: 'contenteditable'
        },
        dataset: {
            readOnly: true,
            error: "Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."
        },
        dir: {
            attribute: 'dir'
        },
        draggable: {
            attribute: 'draggable'
        },
        dropzone: {
            attribute: 'dropzone',
            readOnly: true
        },
        hidden: {
            attribute: 'hidden'
        },
        id: {
            attribute: 'id'
        },
        inputMode: {
            attribute: 'inputmode'
        },
        lang: {
            attribute: 'lang'
        },
        slot: {
            attribute: 'slot',
            error: 'Using the `slot` property is an anti-pattern.'
        },
        spellcheck: {
            attribute: 'spellcheck'
        },
        style: {
            attribute: 'style'
        },
        tabIndex: {
            attribute: 'tabindex'
        },
        title: {
            attribute: 'title'
        },
        translate: {
            attribute: 'translate'
        },
        // additional "global attributes" that are not present in the link above.
        isContentEditable: {
            readOnly: true
        },
        offsetHeight: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetHeight')
        },
        offsetLeft: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetLeft')
        },
        offsetParent: {
            readOnly: true
        },
        offsetTop: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetTop')
        },
        offsetWidth: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetWidth')
        },
        role: {
            attribute: 'role'
        }
    });
    var AttrNameToPropNameMap = create(null);
    var PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach.call(AriaPropertyNames, function (propName) {
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    forEach.call(defaultDefHTMLPropertyNames, function (propName) {
        var attrName = StringToLowerCase$1.call(propName);
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    forEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, function (propName) {
        var attrName = StringToLowerCase$1.call(propName);
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    var CAPS_REGEX = /[A-Z]/g;
    /**
     * This method maps between property names
     * and the corresponding attribute name.
     */
    function getAttrNameFromPropName(propName) {
        if (isUndefined(PropNameToAttrNameMap[propName])) {
            PropNameToAttrNameMap[propName] = StringReplace$1.call(propName, CAPS_REGEX, function (match) { return '-' + match.toLowerCase(); });
        }
        return PropNameToAttrNameMap[propName];
    }
    var controlledElement = null;
    var controlledAttributeName;
    function isAttributeLocked(elm, attrName) {
        return elm !== controlledElement || attrName !== controlledAttributeName;
    }
    function lockAttribute(_elm, _key) {
        controlledElement = null;
        controlledAttributeName = undefined;
    }
    function unlockAttribute(elm, key) {
        controlledElement = elm;
        controlledAttributeName = key;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xmlNS = 'http://www.w3.org/XML/1998/namespace';
    var ColonCharCode = 58;
    function updateAttrs(oldVnode, vnode) {
        var attrs = vnode.data.attrs;
        if (isUndefined(attrs)) {
            return;
        }
        var oldAttrs = oldVnode.data.attrs;
        if (oldAttrs === attrs) {
            return;
        }
        var elm = vnode.elm;
        var key;
        oldAttrs = isUndefined(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes
        // this routine is only useful for data-* attributes in all kind of elements
        // and aria-* in standard elements (custom elements will use props for these)
        for (key in attrs) {
            var cur = attrs[key];
            var old = oldAttrs[key];
            if (old !== cur) {
                unlockAttribute(elm, key);
                if (StringCharCodeAt.call(key, 3) === ColonCharCode) {
                    // Assume xml namespace
                    elm.setAttributeNS(xmlNS, key, cur);
                }
                else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {
                    // Assume xlink namespace
                    elm.setAttributeNS(xlinkNS, key, cur);
                }
                else if (isNull(cur)) {
                    elm.removeAttribute(key);
                }
                else {
                    elm.setAttribute(key, cur);
                }
                lockAttribute();
            }
        }
    }
    var emptyVNode = {
        data: {}
    };
    var modAttrs = {
        create: function (vnode) { return updateAttrs(emptyVNode, vnode); },
        update: updateAttrs
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLiveBindingProp(sel, key) {
        // For properties with live bindings, we read values from the DOM element
        // instead of relying on internally tracked values.
        return sel === 'input' && (key === 'value' || key === 'checked');
    }
    function update(oldVnode, vnode) {
        var props = vnode.data.props;
        if (isUndefined(props)) {
            return;
        }
        var oldProps = oldVnode.data.props;
        if (oldProps === props) {
            return;
        }
        var elm = vnode.elm;
        var isFirstPatch = isUndefined(oldProps);
        var sel = vnode.sel;
        for (var key in props) {
            var cur = props[key];
            if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {
                elm[key] = cur;
            }
        }
    }
    var emptyVNode$1 = {
        data: {}
    };
    var modProps = {
        create: function (vnode) { return update(emptyVNode$1, vnode); },
        update: update
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var classNameToClassMap = create(null);
    function getMapFromClassName(className) {
        // Intentionally using == to match undefined and null values from computed style attribute
        if (className == null) {
            return EmptyObject;
        } // computed class names must be string
        className = isString(className) ? className : className + '';
        var map = classNameToClassMap[className];
        if (map) {
            return map;
        }
        map = create(null);
        var start = 0;
        var o;
        var len = className.length;
        for (o = 0; o < len; o++) {
            if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
                if (o > start) {
                    map[StringSlice.call(className, start, o)] = true;
                }
                start = o + 1;
            }
        }
        if (o > start) {
            map[StringSlice.call(className, start, o)] = true;
        }
        classNameToClassMap[className] = map;
        return map;
    }
    function updateClassAttribute(oldVnode, vnode) {
        var elm = vnode.elm, newClass = vnode.data.className;
        var oldClass = oldVnode.data.className;
        if (oldClass === newClass) {
            return;
        }
        var classList = elm.classList;
        var newClassMap = getMapFromClassName(newClass);
        var oldClassMap = getMapFromClassName(oldClass);
        var name;
        for (name in oldClassMap) {
            // remove only if it is not in the new class collection and it is not set from within the instance
            if (isUndefined(newClassMap[name])) {
                classList.remove(name);
            }
        }
        for (name in newClassMap) {
            if (isUndefined(oldClassMap[name])) {
                classList.add(name);
            }
        }
    }
    var emptyVNode$2 = {
        data: {}
    };
    var modComputedClassName = {
        create: function (vnode) { return updateClassAttribute(emptyVNode$2, vnode); },
        update: updateClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function updateStyleAttribute(oldVnode, vnode) {
        var newStyle = vnode.data.style;
        if (oldVnode.data.style === newStyle) {
            return;
        }
        var elm = vnode.elm;
        var style = elm.style;
        if (!isString(newStyle) || newStyle === '') {
            removeAttribute.call(elm, 'style');
        }
        else {
            style.cssText = newStyle;
        }
    }
    var emptyVNode$3 = {
        data: {}
    };
    var modComputedStyle = {
        create: function (vnode) { return updateStyleAttribute(emptyVNode$3, vnode); },
        update: updateStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.
    function createClassAttribute(vnode) {
        var elm = vnode.elm, classMap = vnode.data.classMap;
        if (isUndefined(classMap)) {
            return;
        }
        var classList = elm.classList;
        for (var name in classMap) {
            classList.add(name);
        }
    }
    var modStaticClassName = {
        create: createClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.
    function createStyleAttribute(vnode) {
        var elm = vnode.elm, styleMap = vnode.data.styleMap;
        if (isUndefined(styleMap)) {
            return;
        }
        var style = elm.style;
        for (var name in styleMap) {
            style[name] = styleMap[name];
        }
    }
    var modStaticStyle = {
        create: createStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2015 Simon Friis Vindum.
    This code may only be used under the MIT License found at
    https://github.com/snabbdom/snabbdom/blob/master/LICENSE
    Code distributed by Snabbdom as part of the Snabbdom project at
    https://github.com/snabbdom/snabbdom/
    */
    function isUndef(s) {
        return s === undefined;
    }
    function sameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVNode(vnode) {
        return vnode != null;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var map = {};
        var j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys
        for (j = beginIdx; j <= endIdx; ++j) {
            ch = children[j];
            if (isVNode(ch)) {
                key = ch.key;
                if (key !== undefined) {
                    map[key] = j;
                }
            }
        }
        return map;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isVNode(ch)) {
                ch.hook.create(ch);
                ch.hook.insert(ch, parentElm, before);
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx]; // text nodes do not have logic associated to them
            if (isVNode(ch)) {
                ch.hook.remove(ch, parentElm);
            }
        }
    }
    function updateDynamicChildren(parentElm, oldCh, newCh) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (!isVNode(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (!isVNode(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (!isVNode(newStartVnode)) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (!isVNode(newEndVnode)) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode);
                newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.elm.nextSibling);
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode);
                newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    // New element
                    newStartVnode.hook.create(newStartVnode);
                    newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (isVNode(elmToMove)) {
                        if (elmToMove.sel !== newStartVnode.sel) {
                            // New element
                            newStartVnode.hook.create(newStartVnode);
                            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                        }
                        else {
                            patchVnode(elmToMove, newStartVnode);
                            oldCh[idxInOld] = undefined;
                            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);
                        }
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                var n = newCh[newEndIdx + 1];
                before = isVNode(n) ? n.elm : null;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function updateStaticChildren(parentElm, oldCh, newCh) {
        var length = newCh.length;
        if (oldCh.length === 0) {
            // the old list is empty, we can directly insert anything new
            addVnodes(parentElm, null, newCh, 0, length);
            return;
        } // if the old list is not empty, the new list MUST have the same
        // amount of nodes, that's why we call this static children
        var referenceElm = null;
        for (var i_3 = length - 1; i_3 >= 0; i_3 -= 1) {
            var vnode = newCh[i_3];
            var oldVNode = oldCh[i_3];
            if (vnode !== oldVNode) {
                if (isVNode(oldVNode)) {
                    if (isVNode(vnode)) {
                        // both vnodes must be equivalent, and se just need to patch them
                        patchVnode(oldVNode, vnode);
                        referenceElm = vnode.elm;
                    }
                    else {
                        // removing the old vnode since the new one is null
                        oldVNode.hook.remove(oldVNode, parentElm);
                    }
                }
                else if (isVNode(vnode)) {
                    // this condition is unnecessary
                    vnode.hook.create(vnode); // insert the new node one since the old one is null
                    vnode.hook.insert(vnode, parentElm, referenceElm);
                    referenceElm = vnode.elm;
                }
            }
        }
    }
    function patchVnode(oldVnode, vnode) {
        if (oldVnode !== vnode) {
            vnode.elm = oldVnode.elm;
            vnode.hook.update(oldVnode, vnode);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */
    var HTMLElementOriginalDescriptors = create(null);
    forEach.call(AriaPropertyNames, function (propName) {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
        var descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);
        if (!isUndefined(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    forEach.call(defaultDefHTMLPropertyNames, function (propName) {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
        // this category, so, better to be sure.
        var descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);
        if (!isUndefined(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    /*
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create$1 = Object.create;
    var _h = Array.prototype, ArraySplice$1 = _h.splice, ArrayIndexOf$1 = _h.indexOf, ArrayPush$1 = _h.push;
    var TargetToReactiveRecordMap = new WeakMap();
    function isUndefined$1(obj) {
        return obj === undefined;
    }
    function getReactiveRecord(target) {
        var reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (isUndefined$1(reactiveRecord)) {
            var newRecord = create$1(null);
            reactiveRecord = newRecord;
            TargetToReactiveRecordMap.set(target, newRecord);
        }
        return reactiveRecord;
    }
    var currentReactiveObserver = null;
    function valueMutated(target, key) {
        var reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (!isUndefined$1(reactiveRecord)) {
            var reactiveObservers = reactiveRecord[key];
            if (!isUndefined$1(reactiveObservers)) {
                for (var i_4 = 0, len = reactiveObservers.length; i_4 < len; i_4 += 1) {
                    var ro = reactiveObservers[i_4];
                    ro.notify();
                }
            }
        }
    }
    function valueObserved(target, key) {
        // We should determine if an active Observing Record is present to track mutations.
        if (currentReactiveObserver === null) {
            return;
        }
        var ro = currentReactiveObserver;
        var reactiveRecord = getReactiveRecord(target);
        var reactiveObservers = reactiveRecord[key];
        if (isUndefined$1(reactiveObservers)) {
            reactiveObservers = [];
            reactiveRecord[key] = reactiveObservers;
        }
        else if (reactiveObservers[0] === ro) {
            return; // perf optimization considering that most subscriptions will come from the same record
        }
        if (ArrayIndexOf$1.call(reactiveObservers, ro) === -1) {
            ro.link(reactiveObservers);
        }
    }
    var ReactiveObserver = /** @class */ (function () {
        function ReactiveObserver(callback) {
            this.listeners = [];
            this.callback = callback;
        }
        ReactiveObserver.prototype.observe = function (job) {
            var inceptionReactiveRecord = currentReactiveObserver;
            currentReactiveObserver = this;
            var error;
            try {
                job();
            }
            catch (e) {
                error = Object(e);
            }
            finally {
                currentReactiveObserver = inceptionReactiveRecord;
                if (error !== undefined) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
            }
        };
        /**
         * This method is responsible for disconnecting the Reactive Observer
         * from any Reactive Record that has a reference to it, to prevent future
         * notifications about previously recorded access.
         */
        ReactiveObserver.prototype.reset = function () {
            var listeners = this.listeners;
            var len = listeners.length;
            if (len > 0) {
                for (var i_5 = 0; i_5 < len; i_5 += 1) {
                    var set = listeners[i_5];
                    var pos = ArrayIndexOf$1.call(listeners[i_5], this);
                    ArraySplice$1.call(set, pos, 1);
                }
                listeners.length = 0;
            }
        }; // friend methods
        ReactiveObserver.prototype.notify = function () {
            this.callback.call(undefined, this);
        };
        ReactiveObserver.prototype.link = function (reactiveObservers) {
            ArrayPush$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on
            ArrayPush$1.call(this.listeners, reactiveObservers);
        };
        return ReactiveObserver;
    }());
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function componentValueMutated(vm, key) {
        valueMutated(vm.component, key);
    }
    function componentValueObserved(vm, key) {
        valueObserved(vm.component, key);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This function builds a Web Component class from a LWC constructor so it can be
     * registered as a new element via customElements.define() at any given time.
     *
     * @deprecated since version 1.3.11
     *
     * @example
     * ```
     * import { buildCustomElementConstructor } from 'lwc';
     * import Foo from 'ns/foo';
     * const WC = buildCustomElementConstructor(Foo);
     * customElements.define('x-foo', WC);
     * const elm = document.createElement('x-foo');
     * ```
     */
    function deprecatedBuildCustomElementConstructor(Ctor) {
        return Ctor.CustomElementConstructor;
    }
    function buildCustomElementConstructor(Ctor) {
        var _a;
        var def = getComponentInternalDef(Ctor); // generating the hash table for attributes to avoid duplicate fields
        // and facilitate validation and false positives in case of inheritance.
        var attributeToPropMap = {};
        for (var propName in def.props) {
            attributeToPropMap[getAttrNameFromPropName(propName)] = propName;
        }
        return _a = /** @class */ (function (_super) {
            __extends(_a, _super);
            function _a() {
                var _this = _super.call(this) || this;
                createVM(_this, def, {
                    mode: 'open',
                    isRoot: true,
                    owner: null
                });
                return _this;
            }
            _a.prototype.connectedCallback = function () {
                connectRootElement(this);
            };
            _a.prototype.disconnectedCallback = function () {
                disconnectedRootElement(this);
            };
            _a.prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
                if (oldValue === newValue) {
                    // ignoring similar values for better perf
                    return;
                }
                var propName = attributeToPropMap[attrName];
                if (isUndefined(propName)) {
                    // ignoring unknown attributes
                    return;
                }
                if (!isAttributeLocked(this, attrName)) {
                    // ignoring changes triggered by the engine itself during:
                    // * diffing when public props are attempting to reflect to the DOM
                    // * component via `this.setAttribute()`, should never update the prop.
                    // Both cases, the the setAttribute call is always wrap by the unlocking
                    // of the attribute to be changed
                    return;
                } // reflect attribute change to the corresponding props when changed
                // from outside.
                this[propName] = newValue;
            };
            return _a;
        }(def.bridge)), // collecting all attribute names from all public props to apply
            // the reflection from attributes to props via attributeChangedCallback.
            _a.observedAttributes = keys(attributeToPropMap), _a;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     */
    function createBridgeToElementDescriptor(propName, descriptor) {
        var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        if (!isFunction(get)) {
            throw new TypeError();
        }
        if (!isFunction(set)) {
            throw new TypeError();
        }
        return {
            enumerable: enumerable,
            configurable: configurable,
            get: function () {
                var vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    return;
                }
                componentValueObserved(vm, propName);
                return get.call(vm.elm);
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (newValue !== vm.cmpProps[propName]) {
                    vm.cmpProps[propName] = newValue;
                    componentValueMutated(vm, propName);
                }
                return set.call(vm.elm, newValue);
            }
        };
    }
    function getLinkedElement(cmp) {
        return getAssociatedVM(cmp).elm;
    }
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     **/
    function BaseLightningElementConstructor() {
        // This should be as performant as possible, while any initialization should be done lazily
        if (isNull(vmBeingConstructed)) {
            throw new ReferenceError('Illegal constructor');
        }
        var vm = vmBeingConstructed;
        var elm = vm.elm, mode = vm.mode, ctor = vm.def.ctor;
        var component = this;
        vm.component = component;
        vm.tro = getTemplateReactiveObserver(vm);
        vm.oar = create(null); // interaction hooks
        // We are intentionally hiding this argument from the formal API of LWCElement because
        // we don't want folks to know about it just yet.
        if (arguments.length === 1) {
            var _b = arguments[0], callHook_1 = _b.callHook, setHook_1 = _b.setHook, getHook_1 = _b.getHook;
            vm.callHook = callHook_1;
            vm.setHook = setHook_1;
            vm.getHook = getHook_1;
        } // attaching the shadowRoot
        var shadowRootOptions = {
            mode: mode,
            delegatesFocus: !!ctor.delegatesFocus,
            '$$lwc-synthetic-mode$$': true
        };
        var cmpRoot = elm.attachShadow(shadowRootOptions); // linking elm, shadow root and component with the VM
        associateVM(component, vm);
        associateVM(cmpRoot, vm);
        associateVM(elm, vm); // VM is now initialized
        vm.cmpRoot = cmpRoot;
        return this;
    }
    BaseLightningElementConstructor.prototype = {
        constructor: BaseLightningElementConstructor,
        dispatchEvent: function () {
            var elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch;
            return elm.dispatchEvent.apply(elm, arguments);
        },
        addEventListener: function (type, listener, options) {
            var vm = getAssociatedVM(this);
            var wrappedListener = getWrappedComponentsListener(vm, listener);
            vm.elm.addEventListener(type, wrappedListener, options);
        },
        removeEventListener: function (type, listener, options) {
            var vm = getAssociatedVM(this);
            var wrappedListener = getWrappedComponentsListener(vm, listener);
            vm.elm.removeEventListener(type, wrappedListener, options);
        },
        hasAttribute: function () {
            var elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return elm.hasAttribute.apply(elm, arguments);
        },
        hasAttributeNS: function () {
            var elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return elm.hasAttributeNS.apply(elm, arguments);
        },
        removeAttribute: function (attrName) {
            var elm = getLinkedElement(this);
            unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.removeAttribute.apply(elm, arguments);
            lockAttribute();
        },
        removeAttributeNS: function (_namespace, attrName) {
            var elm = getLinkedElement(this);
            unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.removeAttributeNS.apply(elm, arguments);
            lockAttribute();
        },
        getAttribute: function () {
            var elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return elm.getAttribute.apply(elm, arguments);
        },
        getAttributeNS: function () {
            var elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            return elm.getAttributeNS.apply(elm, arguments);
        },
        setAttribute: function (attrName) {
            var elm = getLinkedElement(this);
            unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.setAttribute.apply(elm, arguments);
            lockAttribute();
        },
        setAttributeNS: function (_namespace, attrName) {
            var elm = getLinkedElement(this);
            unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch
            elm.setAttributeNS.apply(elm, arguments);
            lockAttribute();
        },
        getBoundingClientRect: function () {
            var elm = getLinkedElement(this);
            // @ts-ignore type-mismatch
            return elm.getBoundingClientRect.apply(elm, arguments);
        },
        /**
         * Returns the first element that is a descendant of node that
         * matches selectors.
         */
        // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
        // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
        querySelector: function () {
            var elm = getLinkedElement(this);
            // @ts-ignore type-mismatch
            return elm.querySelector.apply(elm, arguments);
        },
        /**
         * Returns all element descendants of node that
         * match selectors.
         */
        // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,
        // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,
        querySelectorAll: function () {
            var elm = getLinkedElement(this);
            // @ts-ignore type-mismatch
            return elm.querySelectorAll.apply(elm, arguments);
        },
        /**
         * Returns all element descendants of node that
         * match the provided tagName.
         */
        getElementsByTagName: function () {
            var elm = getLinkedElement(this);
            // @ts-ignore type-mismatch
            return elm.getElementsByTagName.apply(elm, arguments);
        },
        /**
         * Returns all element descendants of node that
         * match the provide classnames.
         */
        getElementsByClassName: function () {
            var elm = getLinkedElement(this);
            // @ts-ignore type-mismatch
            return elm.getElementsByClassName.apply(elm, arguments);
        },
        get isConnected() {
            return getLinkedElement(this).isConnected;
        },
        get classList() {
            return getLinkedElement(this).classList;
        },
        get template() {
            var vm = getAssociatedVM(this);
            return vm.cmpRoot;
        },
        get shadowRoot() {
            // From within the component instance, the shadowRoot is always
            // reported as "closed". Authors should rely on this.template instead.
            return null;
        },
        render: function () {
            var vm = getAssociatedVM(this);
            return vm.def.template;
        },
        toString: function () {
            var vm = getAssociatedVM(this);
            return "[object " + vm.def.name + "]";
        }
    };
    var lightningBasedDescriptors = create(null);
    for (var propName in HTMLElementOriginalDescriptors) {
        lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
    }
    defineProperties(BaseLightningElementConstructor.prototype, lightningBasedDescriptors);
    var ComponentConstructorAsCustomElementConstructorMap = new Map();
    function getCustomElementConstructor(Ctor) {
        if (Ctor === BaseLightningElement) {
            throw new TypeError("Invalid Constructor. LightningElement base class can't be claimed as a custom element.");
        }
        var ce = ComponentConstructorAsCustomElementConstructorMap.get(Ctor);
        if (isUndefined(ce)) {
            ce = buildCustomElementConstructor(Ctor);
            ComponentConstructorAsCustomElementConstructorMap.set(Ctor, ce);
        }
        return ce;
    }
    /**
     * This static getter builds a Web Component class from a LWC constructor
     * so it can be registered as a new element via customElements.define()
     * at any given time. E.g.:
     *
     *      import Foo from 'ns/foo';
     *      customElements.define('x-foo', Foo.CustomElementConstructor);
     *      const elm = document.createElement('x-foo');
     *
     */
    defineProperty(BaseLightningElementConstructor, 'CustomElementConstructor', {
        get: function () {
            return getCustomElementConstructor(this);
        }
    });
    freeze(BaseLightningElementConstructor);
    seal(BaseLightningElementConstructor.prototype); // @ts-ignore
    var BaseLightningElement = BaseLightningElementConstructor;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * @wire decorator to wire fields and methods to a wire adapter in
     * LWC Components. This function implements the internals of this
     * decorator.
     */
    function wire(_adapter, _config) {
        throw new Error();
    }
    function internalWireFieldDecorator(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (value) {
                var vm = getAssociatedVM(this);
                /**
                 * Reactivity for wired fields is provided in wiring.
                 * We intentionally add reactivity here since this is just
                 * letting the author to do the wrong thing, but it will keep our
                 * system to be backward compatible.
                 */
                if (value !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = value;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */
    var isArray$2 = Array.isArray;
    var getPrototypeOf$1 = Object.getPrototypeOf, ObjectDefineProperty = Object.defineProperty, isExtensible = Object.isExtensible, getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, getOwnPropertyNames$1 = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, preventExtensions = Object.preventExtensions, hasOwnProperty$2 = Object.hasOwnProperty;
    var _j = Array.prototype, ArrayConcat = _j.concat;
    function isUndefined$2(obj) {
        return obj === undefined;
    }
    function isFunction$1(obj) {
        return typeof obj === 'function';
    }
    function isObject$2(obj) {
        return typeof obj === 'object';
    }
    var proxyToValueMap = new WeakMap();
    function registerProxy(proxy, value) {
        proxyToValueMap.set(proxy, value);
    }
    var unwrap = function (replicaOrAny) { return proxyToValueMap.get(replicaOrAny) || replicaOrAny; };
    function wrapValue(membrane, value) {
        return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
    }
    /**
     * Unwrap property descriptors will set value on original descriptor
     * We only need to unwrap if value is specified
     * @param descriptor external descrpitor provided to define new property on original value
     */
    function unwrapDescriptor(descriptor) {
        if (hasOwnProperty$2.call(descriptor, 'value')) {
            descriptor.value = unwrap(descriptor.value);
        }
        return descriptor;
    }
    function lockShadowTarget(membrane, shadowTarget, originalTarget) {
        var targetKeys = ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        targetKeys.forEach(function (key) {
            var descriptor = getOwnPropertyDescriptor$1(originalTarget, key); // We do not need to wrap the descriptor if configurable
            // Because we can deal with wrapping it when user goes through
            // Get own property descriptor. There is also a chance that this descriptor
            // could change sometime in the future, so we can defer wrapping
            // until we need to
            if (!descriptor.configurable) {
                descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
            }
            ObjectDefineProperty(shadowTarget, key, descriptor);
        });
        preventExtensions(shadowTarget);
    }
    var ReactiveProxyHandler = /** @class */ (function () {
        function ReactiveProxyHandler(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        ReactiveProxyHandler.prototype.get = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var value = originalTarget[key];
            var valueObserved = membrane.valueObserved;
            valueObserved(originalTarget, key);
            return membrane.getProxy(value);
        };
        ReactiveProxyHandler.prototype.set = function (shadowTarget, key, value) {
            var _b = this, originalTarget = _b.originalTarget, valueMutated = _b.membrane.valueMutated;
            var oldValue = originalTarget[key];
            if (oldValue !== value) {
                originalTarget[key] = value;
                valueMutated(originalTarget, key);
            }
            else if (key === 'length' && isArray$2(originalTarget)) {
                // fix for issue #236: push will add the new index, and by the time length
                // is updated, the internal length is already equal to the new length value
                // therefore, the oldValue is equal to the value. This is the forking logic
                // to support this use case.
                valueMutated(originalTarget, key);
            }
            return true;
        };
        ReactiveProxyHandler.prototype.deleteProperty = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueMutated = _b.membrane.valueMutated;
            delete originalTarget[key];
            valueMutated(originalTarget, key);
            return true;
        };
        ReactiveProxyHandler.prototype.apply = function (shadowTarget, thisArg, argArray) {
            /* No op */
        };
        ReactiveProxyHandler.prototype.construct = function (target, argArray, newTarget) {
            /* No op */
        };
        ReactiveProxyHandler.prototype.has = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueObserved = _b.membrane.valueObserved;
            valueObserved(originalTarget, key);
            return key in originalTarget;
        };
        ReactiveProxyHandler.prototype.ownKeys = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        };
        ReactiveProxyHandler.prototype.isExtensible = function (shadowTarget) {
            var shadowIsExtensible = isExtensible(shadowTarget);
            if (!shadowIsExtensible) {
                return shadowIsExtensible;
            }
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var targetIsExtensible = isExtensible(originalTarget);
            if (!targetIsExtensible) {
                lockShadowTarget(membrane, shadowTarget, originalTarget);
            }
            return targetIsExtensible;
        };
        ReactiveProxyHandler.prototype.setPrototypeOf = function (shadowTarget, prototype) {
        };
        ReactiveProxyHandler.prototype.getPrototypeOf = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return getPrototypeOf$1(originalTarget);
        };
        ReactiveProxyHandler.prototype.getOwnPropertyDescriptor = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var valueObserved = this.membrane.valueObserved; // keys looked up via hasOwnProperty need to be reactive
            valueObserved(originalTarget, key);
            var desc = getOwnPropertyDescriptor$1(originalTarget, key);
            if (isUndefined$2(desc)) {
                return desc;
            }
            var shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);
            if (!isUndefined$2(shadowDescriptor)) {
                return shadowDescriptor;
            } // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value, setter or getter (if available) cannot observe
            // mutations, just like regular methods, in which case we just do nothing.
            desc = wrapDescriptor(membrane, desc, wrapValue);
            if (!desc.configurable) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                ObjectDefineProperty(shadowTarget, key, desc);
            }
            return desc;
        };
        ReactiveProxyHandler.prototype.preventExtensions = function (shadowTarget) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            lockShadowTarget(membrane, shadowTarget, originalTarget);
            preventExtensions(originalTarget);
            return true;
        };
        ReactiveProxyHandler.prototype.defineProperty = function (shadowTarget, key, descriptor) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var valueMutated = membrane.valueMutated;
            var configurable = descriptor.configurable; // We have to check for value in descriptor
            // because Object.freeze(proxy) calls this method
            // with only { configurable: false, writeable: false }
            // Additionally, method will only be called with writeable:false
            // if the descriptor has a value, as opposed to getter/setter
            // So we can just check if writable is present and then see if
            // value is present. This eliminates getter and setter descriptors
            if (hasOwnProperty$2.call(descriptor, 'writable') && !hasOwnProperty$2.call(descriptor, 'value')) {
                var originalDescriptor = getOwnPropertyDescriptor$1(originalTarget, key);
                descriptor.value = originalDescriptor.value;
            }
            ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));
            if (configurable === false) {
                ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
            }
            valueMutated(originalTarget, key);
            return true;
        };
        return ReactiveProxyHandler;
    }());
    function wrapReadOnlyValue(membrane, value) {
        return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
    }
    var ReadOnlyHandler = /** @class */ (function () {
        function ReadOnlyHandler(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        ReadOnlyHandler.prototype.get = function (shadowTarget, key) {
            var _b = this, membrane = _b.membrane, originalTarget = _b.originalTarget;
            var value = originalTarget[key];
            var valueObserved = membrane.valueObserved;
            valueObserved(originalTarget, key);
            return membrane.getReadOnlyProxy(value);
        };
        ReadOnlyHandler.prototype.set = function (shadowTarget, key, value) {
            return false;
        };
        ReadOnlyHandler.prototype.deleteProperty = function (shadowTarget, key) {
            return false;
        };
        ReadOnlyHandler.prototype.apply = function (shadowTarget, thisArg, argArray) {
            /* No op */
        };
        ReadOnlyHandler.prototype.construct = function (target, argArray, newTarget) {
            /* No op */
        };
        ReadOnlyHandler.prototype.has = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueObserved = _b.membrane.valueObserved;
            valueObserved(originalTarget, key);
            return key in originalTarget;
        };
        ReadOnlyHandler.prototype.ownKeys = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        };
        ReadOnlyHandler.prototype.setPrototypeOf = function (shadowTarget, prototype) {
        };
        ReadOnlyHandler.prototype.getOwnPropertyDescriptor = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var valueObserved = membrane.valueObserved; // keys looked up via hasOwnProperty need to be reactive
            valueObserved(originalTarget, key);
            var desc = getOwnPropertyDescriptor$1(originalTarget, key);
            if (isUndefined$2(desc)) {
                return desc;
            }
            var shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);
            if (!isUndefined$2(shadowDescriptor)) {
                return shadowDescriptor;
            } // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value or getter (if available) cannot be observed,
            // just like regular methods, in which case we just do nothing.
            desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);
            if (hasOwnProperty$2.call(desc, 'set')) {
                desc.set = undefined; // readOnly membrane does not allow setters
            }
            if (!desc.configurable) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                ObjectDefineProperty(shadowTarget, key, desc);
            }
            return desc;
        };
        ReadOnlyHandler.prototype.preventExtensions = function (shadowTarget) {
            return false;
        };
        ReadOnlyHandler.prototype.defineProperty = function (shadowTarget, key, descriptor) {
            return false;
        };
        return ReadOnlyHandler;
    }());
    function createShadowTarget(value) {
        var shadowTarget = undefined;
        if (isArray$2(value)) {
            shadowTarget = [];
        }
        else if (isObject$2(value)) {
            shadowTarget = {};
        }
        return shadowTarget;
    }
    var ObjectDotPrototype = Object.prototype;
    function defaultValueIsObservable(value) {
        // intentionally checking for null
        if (value === null) {
            return false;
        } // treat all non-object types, including undefined, as non-observable values
        if (typeof value !== 'object') {
            return false;
        }
        if (isArray$2(value)) {
            return true;
        }
        var proto = getPrototypeOf$1(value);
        return proto === ObjectDotPrototype || proto === null || getPrototypeOf$1(proto) === null;
    }
    var defaultValueObserved = function (obj, key) {
        /* do nothing */
    };
    var defaultValueMutated = function (obj, key) {
        /* do nothing */
    };
    var defaultValueDistortion = function (value) { return value; };
    function wrapDescriptor(membrane, descriptor, getValue) {
        var set = descriptor.set, get = descriptor.get;
        if (hasOwnProperty$2.call(descriptor, 'value')) {
            descriptor.value = getValue(membrane, descriptor.value);
        }
        else {
            if (!isUndefined$2(get)) {
                descriptor.get = function () {
                    // invoking the original getter with the original target
                    return getValue(membrane, get.call(unwrap(this)));
                };
            }
            if (!isUndefined$2(set)) {
                descriptor.set = function (value) {
                    // At this point we don't have a clear indication of whether
                    // or not a valid mutation will occur, we don't have the key,
                    // and we are not sure why and how they are invoking this setter.
                    // Nevertheless we preserve the original semantics by invoking the
                    // original setter with the original target and the unwrapped value
                    set.call(unwrap(this), membrane.unwrapProxy(value));
                };
            }
        }
        return descriptor;
    }
    var ReactiveMembrane = /** @class */ (function () {
        function ReactiveMembrane(options) {
            this.valueDistortion = defaultValueDistortion;
            this.valueMutated = defaultValueMutated;
            this.valueObserved = defaultValueObserved;
            this.valueIsObservable = defaultValueIsObservable;
            this.objectGraph = new WeakMap();
            if (!isUndefined$2(options)) {
                var valueDistortion_1 = options.valueDistortion, valueMutated_1 = options.valueMutated, valueObserved_1 = options.valueObserved, valueIsObservable = options.valueIsObservable;
                this.valueDistortion = isFunction$1(valueDistortion_1) ? valueDistortion_1 : defaultValueDistortion;
                this.valueMutated = isFunction$1(valueMutated_1) ? valueMutated_1 : defaultValueMutated;
                this.valueObserved = isFunction$1(valueObserved_1) ? valueObserved_1 : defaultValueObserved;
                this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
            }
        }
        ReactiveMembrane.prototype.getProxy = function (value) {
            var unwrappedValue = unwrap(value);
            var distorted = this.valueDistortion(unwrappedValue);
            if (this.valueIsObservable(distorted)) {
                var o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly
                // we return the readonly.
                return o.readOnly === value ? value : o.reactive;
            }
            return distorted;
        };
        ReactiveMembrane.prototype.getReadOnlyProxy = function (value) {
            value = unwrap(value);
            var distorted = this.valueDistortion(value);
            if (this.valueIsObservable(distorted)) {
                return this.getReactiveState(value, distorted).readOnly;
            }
            return distorted;
        };
        ReactiveMembrane.prototype.unwrapProxy = function (p) {
            return unwrap(p);
        };
        ReactiveMembrane.prototype.getReactiveState = function (value, distortedValue) {
            var objectGraph = this.objectGraph;
            var reactiveState = objectGraph.get(distortedValue);
            if (reactiveState) {
                return reactiveState;
            }
            var membrane = this;
            reactiveState = {
                get reactive() {
                    var reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed
                    var proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'reactive', {
                        value: proxy
                    });
                    return proxy;
                },
                get readOnly() {
                    var readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed
                    var proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'readOnly', {
                        value: proxy
                    });
                    return proxy;
                }
            };
            objectGraph.set(distortedValue, reactiveState);
            return reactiveState;
        };
        return ReactiveMembrane;
    }());
    /** version: 0.26.0 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function valueDistortion(value) {
        return value;
    }
    var reactiveMembrane = new ReactiveMembrane({
        valueObserved: valueObserved,
        valueMutated: valueMutated,
        valueDistortion: valueDistortion
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     */
    var unwrap$1 = function (value) {
        var unwrapped = reactiveMembrane.unwrapProxy(value);
        if (unwrapped !== value) {
            // if value is a proxy, unwrap to access original value and apply distortion
            return valueDistortion(unwrapped);
        }
        return value;
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function track(target) {
        if (arguments.length === 1) {
            return reactiveMembrane.getProxy(target);
        }
        throw new Error();
    }
    function internalTrackDecorator(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                var reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);
                if (reactiveOrAnyValue !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = reactiveOrAnyValue;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create$2 = Object.create;
    function isUndefined$3(obj) {
        return obj === undefined;
    }
    function isTrue$1$1(obj) {
        return obj === true;
    }
    function isFalse$1$1(obj) {
        return obj === false;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
    /** version: 1.6.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Cached reference to globalThis
    var _globalThis;
    if (typeof globalThis === 'object') {
        _globalThis = globalThis;
    }
    function getGlobalThis() {
        if (typeof _globalThis === 'object') {
            return _globalThis;
        }
        try {
            // eslint-disable-next-line no-extend-native
            Object.defineProperty(Object.prototype, '__magic__', {
                get: function () {
                    return this;
                },
                configurable: true
            }); // @ts-ignore
            // __magic__ is undefined in Safari 10 and IE10 and older.
            // eslint-disable-next-line no-undef
            _globalThis = __magic__; // @ts-ignore
            delete Object.prototype.__magic__;
        }
        catch (ex) { // In IE8, Object.defineProperty only works on DOM objects.
        }
        finally {
            // If the magic above fails for some reason we assume that we are in a
            // legacy browser. Assume `window` exists in this case.
            if (typeof _globalThis === 'undefined') {
                _globalThis = window;
            }
        }
        return _globalThis;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var _globalThis$1 = getGlobalThis();
    if (!_globalThis$1.lwcRuntimeFlags) {
        Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
            value: create$2(null)
        });
    }
    var runtimeFlags = _globalThis$1.lwcRuntimeFlags; // This function is not supported for use within components and is meant for
    // configuring runtime feature flags during app initialization.
    function setFeatureFlag(name, value) {
        var isBoolean = isTrue$1$1(value) || isFalse$1$1(value);
        if (!isBoolean) {
            var message = "Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\". Runtime feature flags can only be set to a boolean value.";
            {
                // eslint-disable-next-line no-console
                console.error(message);
                return;
            }
        }
        if (isUndefined$3(featureFlagLookup[name])) {
            // eslint-disable-next-line no-console
            console.warn("Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.");
            return;
        }
        {
            // Disallow the same flag to be set more than once in production
            var runtimeValue = runtimeFlags[name];
            if (!isUndefined$3(runtimeValue)) {
                // eslint-disable-next-line no-console
                console.error("Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\". \"" + name + "\" has already been set with the value \"" + runtimeValue + "\".");
                return;
            }
            Object.defineProperty(runtimeFlags, name, {
                value: value
            });
        }
    } // This function is exposed to components to facilitate testing so we add a
    // check to make sure it is not invoked in production.
    function setFeatureFlagForTest(name, value) {
    }
    var featureFlagLookup = {
        ENABLE_REACTIVE_SETTER: null,
        // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.
        ENABLE_ELEMENT_PATCH: null,
        ENABLE_NODE_LIST_PATCH: null,
        ENABLE_HTML_COLLECTIONS_PATCH: null,
        ENABLE_NODE_PATCH: null
    };
    /** version: 1.6.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function api() {
        throw new Error();
    }
    function createPublicPropertyDescriptor(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    return;
                }
                componentValueObserved(vm, key);
                return vm.cmpProps[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                vm.cmpProps[key] = newValue;
                componentValueMutated(vm, key);
            },
            enumerable: true,
            configurable: true
        };
    }
    var AccessorReactiveObserver = /** @class */ (function (_super) {
        __extends(AccessorReactiveObserver, _super);
        function AccessorReactiveObserver(vm, set) {
            var _this = _super.call(this, function () {
                if (isFalse$1(_this.debouncing)) {
                    _this.debouncing = true;
                    addCallbackToNextTick(function () {
                        if (isTrue$1(_this.debouncing)) {
                            var value = _this.value;
                            var dirtyStateBeforeSetterCall = vm.isDirty, component = vm.component, idx_1 = vm.idx;
                            set.call(component, value); // de-bouncing after the call to the original setter to prevent
                            // infinity loop if the setter itself is mutating things that
                            // were accessed during the previous invocation.
                            _this.debouncing = false;
                            if (isTrue$1(vm.isDirty) && isFalse$1(dirtyStateBeforeSetterCall) && idx_1 > 0) {
                                // immediate rehydration due to a setter driven mutation, otherwise
                                // the component will get rendered on the second tick, which it is not
                                // desirable.
                                rerenderVM(vm);
                            }
                        }
                    });
                }
            }) || this;
            _this.debouncing = false;
            return _this;
        }
        AccessorReactiveObserver.prototype.reset = function (value) {
            _super.prototype.reset.call(this);
            this.debouncing = false;
            if (arguments.length > 0) {
                this.value = value;
            }
        };
        return AccessorReactiveObserver;
    }(ReactiveObserver));
    function createPublicAccessorDescriptor(key, descriptor) {
        var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        if (!isFunction(get)) {
            throw new Error();
        }
        return {
            get: function () {
                return get.call(this);
            },
            set: function (newValue) {
                var _this = this;
                var vm = getAssociatedVM(this);
                if (set) {
                    if (runtimeFlags.ENABLE_REACTIVE_SETTER) {
                        var ro = vm.oar[key];
                        if (isUndefined(ro)) {
                            ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);
                        } // every time we invoke this setter from outside (through this wrapper setter)
                        // we should reset the value and then debounce just in case there is a pending
                        // invocation the next tick that is not longer relevant since the value is changing
                        // from outside.
                        ro.reset(newValue);
                        ro.observe(function () {
                            set.call(_this, newValue);
                        });
                    }
                    else {
                        set.call(this, newValue);
                    }
                }
            },
            enumerable: enumerable,
            configurable: configurable
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ShadowRootInnerHTMLSetter = getOwnPropertyDescriptor(ShadowRoot.prototype, 'innerHTML').set;
    var dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    var WireMetaMap = new Map();
    function noop() { }
    function createFieldDataCallback(vm, name) {
        var cmpFields = vm.cmpFields;
        return function (value) {
            if (value !== vm.cmpFields[name]) {
                // storing the value in the underlying storage
                cmpFields[name] = value;
                componentValueMutated(vm, name);
            }
        };
    }
    function createMethodDataCallback(vm, method) {
        return function (value) {
            // dispatching new value into the wired method
            invokeComponentCallback(vm, method, [value]);
        };
    }
    function createConfigWatcher(vm, wireDef, callbackWhenConfigIsReady) {
        var component = vm.component;
        var configCallback = wireDef.configCallback;
        var hasPendingConfig = false; // creating the reactive observer for reactive params when needed
        var ro = new ReactiveObserver(function () {
            if (hasPendingConfig === false) {
                hasPendingConfig = true; // collect new config in the micro-task
                Promise.resolve().then(function () {
                    hasPendingConfig = false; // resetting current reactive params
                    ro.reset(); // dispatching a new config due to a change in the configuration
                    callback();
                });
            }
        });
        var callback = function () {
            var config;
            ro.observe(function () { return config = configCallback(component); }); // eslint-disable-next-line lwc-internal/no-invalid-todo
            // TODO: dev-mode validation of config based on the adapter.configSchema
            // @ts-ignore it is assigned in the observe() callback
            callbackWhenConfigIsReady(config);
        };
        return callback;
    }
    function createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {
        var adapter = wireDef.adapter;
        var adapterContextToken = getAdapterToken(adapter);
        if (isUndefined(adapterContextToken)) {
            return; // no provider found, nothing to be done
        }
        var elm = vm.elm, _b = vm.context, wiredConnecting = _b.wiredConnecting, wiredDisconnecting = _b.wiredDisconnecting; // waiting for the component to be connected to formally request the context via the token
        ArrayPush.call(wiredConnecting, function () {
            // This event is responsible for connecting the host element with another
            // element in the composed path that is providing contextual data. The provider
            // must be listening for a special dom event with the name corresponding to the value of
            // `adapterContextToken`, which will remain secret and internal to this file only to
            // guarantee that the linkage can be forged.
            var internalDomEvent = new CustomEvent(adapterContextToken, {
                bubbles: true,
                composed: true,
                detail: function (newContext, disconnectCallback) {
                    // adds this callback into the disconnect bucket so it gets disconnected from parent
                    // the the element hosting the wire is disconnected
                    ArrayPush.call(wiredDisconnecting, disconnectCallback); // eslint-disable-next-line lwc-internal/no-invalid-todo
                    // TODO: dev-mode validation of config based on the adapter.contextSchema
                    callbackWhenContextIsReady(newContext);
                }
            });
            dispatchEvent.call(elm, internalDomEvent);
        });
    }
    function createConnector(vm, name, wireDef) {
        var method = wireDef.method, adapter = wireDef.adapter, configCallback = wireDef.configCallback, hasParams = wireDef.hasParams;
        var component = vm.component;
        var dataCallback = isUndefined(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);
        var context;
        var connector; // Workaround to pass the component element associated to this wire adapter instance.
        defineProperty(dataCallback, DeprecatedWiredElementHost, {
            value: vm.elm
        });
        runWithBoundaryProtection(vm, vm, noop, function () {
            // job
            connector = new adapter(dataCallback);
        }, noop);
        var updateConnectorConfig = function (config) {
            // every time the config is recomputed due to tracking,
            // this callback will be invoked with the new computed config
            runWithBoundaryProtection(vm, vm, noop, function () {
                // job
                connector.update(config, context);
            }, noop);
        }; // Computes the current wire config and calls the update method on the wire adapter.
        // This initial implementation may change depending on the specific wire instance, if it has params, we will need
        // to observe changes in the next tick.
        var computeConfigAndUpdate = function () {
            updateConnectorConfig(configCallback(component));
        };
        if (hasParams) {
            // This wire has dynamic parameters: we wait for the component instance is created and its values set
            // in order to call the update(config) method.
            Promise.resolve().then(function () {
                computeConfigAndUpdate = createConfigWatcher(vm, wireDef, updateConnectorConfig);
                computeConfigAndUpdate();
            });
        }
        else {
            computeConfigAndUpdate();
        } // if the adapter needs contextualization, we need to watch for new context and push it alongside the config
        if (!isUndefined(adapter.contextSchema)) {
            createContextWatcher(vm, wireDef, function (newContext) {
                // every time the context is pushed into this component,
                // this callback will be invoked with the new computed context
                if (context !== newContext) {
                    context = newContext; // Note: when new context arrives, the config will be recomputed and pushed along side the new
                    // context, this is to preserve the identity characteristics, config should not have identity
                    // (ever), while context can have identity
                    computeConfigAndUpdate();
                }
            });
        } // @ts-ignore the boundary protection executes sync, connector is always defined
        return connector;
    }
    var AdapterToTokenMap = new Map();
    function getAdapterToken(adapter) {
        return AdapterToTokenMap.get(adapter);
    }
    function setAdapterToken(adapter, token) {
        AdapterToTokenMap.set(adapter, token);
    }
    function storeWiredMethodMeta(descriptor, adapter, configCallback, hasParams) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        var method = descriptor.value;
        var def = {
            adapter: adapter,
            method: method,
            configCallback: configCallback,
            hasParams: hasParams
        };
        WireMetaMap.set(descriptor, def);
    }
    function storeWiredFieldMeta(descriptor, adapter, configCallback, hasParams) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        var def = {
            adapter: adapter,
            configCallback: configCallback,
            hasParams: hasParams
        };
        WireMetaMap.set(descriptor, def);
    }
    function installWireAdapters(vm) {
        var wire = vm.def.wire;
        if (getOwnPropertyNames(wire).length === 0) ;
        else {
            var connect = vm.context.wiredConnecting = [];
            var disconnect = vm.context.wiredDisconnecting = [];
            var _loop_1 = function (fieldNameOrMethod) {
                var descriptor = wire[fieldNameOrMethod];
                var wireDef = WireMetaMap.get(descriptor);
                if (!isUndefined(wireDef)) {
                    var adapterInstance_1 = createConnector(vm, fieldNameOrMethod, wireDef);
                    ArrayPush.call(connect, function () { return adapterInstance_1.connect(); });
                    ArrayPush.call(disconnect, function () { return adapterInstance_1.disconnect(); });
                }
            };
            for (var fieldNameOrMethod in wire) {
                _loop_1(fieldNameOrMethod);
            }
        }
    }
    function connectWireAdapters(vm) {
        var wiredConnecting = vm.context.wiredConnecting;
        for (var i_6 = 0, len = wiredConnecting.length; i_6 < len; i_6 += 1) {
            wiredConnecting[i_6]();
        }
    }
    function disconnectWireAdapters(vm) {
        var wiredDisconnecting = vm.context.wiredDisconnecting;
        runWithBoundaryProtection(vm, vm, noop, function () {
            // job
            for (var i_7 = 0, len = wiredDisconnecting.length; i_7 < len; i_7 += 1) {
                wiredDisconnecting[i_7]();
            }
        }, noop);
    }
    function createObservedFieldPropertyDescriptor(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (newValue !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = newValue;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var PropType;
    (function (PropType) {
        PropType[PropType["Field"] = 0] = "Field";
        PropType[PropType["Set"] = 1] = "Set";
        PropType[PropType["Get"] = 2] = "Get";
        PropType[PropType["GetSet"] = 3] = "GetSet";
    })(PropType || (PropType = {}));
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by user-land code.
     */
    function registerDecorators(Ctor, meta) {
        var proto = Ctor.prototype;
        var publicProps = meta.publicProps, publicMethods = meta.publicMethods, wire = meta.wire, track = meta.track, fields = meta.fields;
        var apiMethods = create(null);
        var apiFields = create(null);
        var wiredMethods = create(null);
        var wiredFields = create(null);
        var observedFields = create(null);
        var apiFieldsConfig = create(null);
        var descriptor;
        if (!isUndefined(publicProps)) {
            for (var fieldName in publicProps) {
                var propConfig = publicProps[fieldName];
                apiFieldsConfig[fieldName] = propConfig.config;
                descriptor = getOwnPropertyDescriptor(proto, fieldName);
                if (propConfig.config > 0) {
                    if (isUndefined(descriptor)) {
                        throw new Error();
                    }
                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
                }
                else {
                    descriptor = createPublicPropertyDescriptor(fieldName);
                }
                apiFields[fieldName] = descriptor;
                defineProperty(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined(publicMethods)) {
            forEach.call(publicMethods, function (methodName) {
                descriptor = getOwnPropertyDescriptor(proto, methodName);
                if (isUndefined(descriptor)) {
                    throw new Error();
                }
                apiMethods[methodName] = descriptor;
            });
        }
        if (!isUndefined(wire)) {
            for (var fieldOrMethodName in wire) {
                var _b = wire[fieldOrMethodName], adapter = _b.adapter, method = _b.method, configCallback = _b.config, hasParams = _b.hasParams;
                descriptor = getOwnPropertyDescriptor(proto, fieldOrMethodName);
                if (method === 1) {
                    if (isUndefined(descriptor)) {
                        throw new Error();
                    }
                    wiredMethods[fieldOrMethodName] = descriptor;
                    storeWiredMethodMeta(descriptor, adapter, configCallback, hasParams);
                }
                else {
                    descriptor = internalWireFieldDecorator(fieldOrMethodName);
                    wiredFields[fieldOrMethodName] = descriptor;
                    storeWiredFieldMeta(descriptor, adapter, configCallback, hasParams);
                    defineProperty(proto, fieldOrMethodName, descriptor);
                }
            }
        }
        if (!isUndefined(track)) {
            for (var fieldName in track) {
                descriptor = getOwnPropertyDescriptor(proto, fieldName);
                descriptor = internalTrackDecorator(fieldName);
                defineProperty(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined(fields)) {
            for (var i_8 = 0, n = fields.length; i_8 < n; i_8++) {
                var fieldName = fields[i_8];
                descriptor = getOwnPropertyDescriptor(proto, fieldName);
                observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);
            }
        }
        setDecoratorsMeta(Ctor, {
            apiMethods: apiMethods,
            apiFields: apiFields,
            apiFieldsConfig: apiFieldsConfig,
            wiredMethods: wiredMethods,
            wiredFields: wiredFields,
            observedFields: observedFields
        });
        return Ctor;
    }
    var signedDecoratorToMetaMap = new Map();
    function setDecoratorsMeta(Ctor, meta) {
        signedDecoratorToMetaMap.set(Ctor, meta);
    }
    var defaultMeta = {
        apiMethods: EmptyObject,
        apiFields: EmptyObject,
        apiFieldsConfig: EmptyObject,
        wiredMethods: EmptyObject,
        wiredFields: EmptyObject,
        observedFields: EmptyObject
    };
    function getDecoratorsMeta(Ctor) {
        var meta = signedDecoratorToMetaMap.get(Ctor);
        return isUndefined(meta) ? defaultMeta : meta;
    }
    var signedTemplateSet = new Set();
    function defaultEmptyTemplate() {
        return [];
    }
    signedTemplateSet.add(defaultEmptyTemplate);
    function isTemplateRegistered(tpl) {
        return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerTemplate(tpl) {
        signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing
        // assignment of templates easily, without too much transformation
        return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker
     * Service and other similar libraries to sanitize vulnerable attributes.
     * This API is subject to change or being removed.
     */
    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
        // locker-service patches this function during runtime to sanitize vulnerable attributes.
        // when ran off-core this function becomes a noop and returns the user authored value.
        return attrValue;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:
    var cachedGetterByKey = create(null);
    var cachedSetterByKey = create(null);
    function createGetter(key) {
        var fn = cachedGetterByKey[key];
        if (isUndefined(fn)) {
            fn = cachedGetterByKey[key] = function () {
                var vm = getAssociatedVM(this);
                var getHook = vm.getHook;
                return getHook(vm.component, key);
            };
        }
        return fn;
    }
    function createSetter(key) {
        var fn = cachedSetterByKey[key];
        if (isUndefined(fn)) {
            fn = cachedSetterByKey[key] = function (newValue) {
                var vm = getAssociatedVM(this);
                var setHook = vm.setHook;
                newValue = reactiveMembrane.getReadOnlyProxy(newValue);
                setHook(vm.component, key, newValue);
            };
        }
        return fn;
    }
    function createMethodCaller(methodName) {
        return function () {
            var vm = getAssociatedVM(this);
            var callHook = vm.callHook, component = vm.component;
            var fn = component[methodName];
            return callHook(vm.component, fn, ArraySlice$1.call(arguments));
        };
    }
    function HTMLBridgeElementFactory(SuperClass, props, methods) {
        var HTMLBridgeElement;
        /**
         * Modern browsers will have all Native Constructors as regular Classes
         * and must be instantiated with the new keyword. In older browsers,
         * specifically IE11, those are objects with a prototype property defined,
         * since they are not supposed to be extended or instantiated with the
         * new keyword. This forking logic supports both cases, specifically because
         * wc.ts relies on the construction path of the bridges to create new
         * fully qualifying web components.
         */
        if (isFunction(SuperClass)) {
            HTMLBridgeElement = /** @class */ (function (_super) {
                __extends(HTMLBridgeElement, _super);
                function HTMLBridgeElement() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return HTMLBridgeElement;
            }(SuperClass));
        }
        else {
            HTMLBridgeElement = function () {
                // Bridge classes are not supposed to be instantiated directly in
                // browsers that do not support web components.
                throw new TypeError('Illegal constructor');
            }; // prototype inheritance dance
            setPrototypeOf(HTMLBridgeElement, SuperClass);
            setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);
            defineProperty(HTMLBridgeElement.prototype, 'constructor', {
                writable: true,
                configurable: true,
                value: HTMLBridgeElement
            });
        }
        var descriptors = create(null); // expose getters and setters for each public props on the new Element Bridge
        for (var i_9 = 0, len = props.length; i_9 < len; i_9 += 1) {
            var propName = props[i_9];
            descriptors[propName] = {
                get: createGetter(propName),
                set: createSetter(propName),
                enumerable: true,
                configurable: true
            };
        } // expose public methods as props on the new Element Bridge
        for (var i_10 = 0, len = methods.length; i_10 < len; i_10 += 1) {
            var methodName = methods[i_10];
            descriptors[methodName] = {
                value: createMethodCaller(methodName),
                writable: true,
                configurable: true
            };
        }
        defineProperties(HTMLBridgeElement.prototype, descriptors);
        return HTMLBridgeElement;
    }
    var BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, getOwnPropertyNames(HTMLElementOriginalDescriptors), []);
    freeze(BaseBridgeElement);
    seal(BaseBridgeElement.prototype);
    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function resolveCircularModuleDependency(fn) {
        return fn();
    }
    function isCircularModuleDependency(obj) {
        return isFunction(obj) && hasOwnProperty$1.call(obj, '__circular__');
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CtorToDefMap = new WeakMap();
    function getCtorProto(Ctor, subclassComponentName) {
        var proto = getPrototypeOf(Ctor);
        if (isNull(proto)) {
            throw new ReferenceError("Invalid prototype chain for " + subclassComponentName + ", you must extend LightningElement.");
        } // covering the cases where the ref is circular in AMD
        if (isCircularModuleDependency(proto)) {
            var p = resolveCircularModuleDependency(proto);
            // of our Base class without having to leak it to user-land. If the circular function returns
            // itself, that's the signal that we have hit the end of the proto chain, which must always
            // be base.
            proto = p === proto ? BaseLightningElement : p;
        }
        return proto;
    }
    function createComponentDef(Ctor, meta, subclassComponentName) {
        var name = meta.name;
        var template = meta.template;
        var decoratorsMeta = getDecoratorsMeta(Ctor);
        var apiFields = decoratorsMeta.apiFields, apiFieldsConfig = decoratorsMeta.apiFieldsConfig, apiMethods = decoratorsMeta.apiMethods, wiredFields = decoratorsMeta.wiredFields, wiredMethods = decoratorsMeta.wiredMethods, observedFields = decoratorsMeta.observedFields;
        var proto = Ctor.prototype;
        var connectedCallback = proto.connectedCallback, disconnectedCallback = proto.disconnectedCallback, renderedCallback = proto.renderedCallback, errorCallback = proto.errorCallback, render = proto.render;
        var superProto = getCtorProto(Ctor, subclassComponentName);
        var superDef = superProto !== BaseLightningElement ? getComponentInternalDef(superProto, subclassComponentName) : lightingElementDef;
        var SuperBridge = isNull(superDef) ? BaseBridgeElement : superDef.bridge;
        var bridge = HTMLBridgeElementFactory(SuperBridge, keys(apiFields), keys(apiMethods));
        var props = assign(create(null), superDef.props, apiFields);
        var propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);
        var methods = assign(create(null), superDef.methods, apiMethods);
        var wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        render = render || superDef.render;
        template = template || superDef.template; // installing observed fields into the prototype.
        defineProperties(proto, observedFields);
        var def = {
            ctor: Ctor,
            name: name,
            wire: wire,
            props: props,
            propsConfig: propsConfig,
            methods: methods,
            bridge: bridge,
            template: template,
            connectedCallback: connectedCallback,
            disconnectedCallback: disconnectedCallback,
            renderedCallback: renderedCallback,
            errorCallback: errorCallback,
            render: render
        };
        return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is
     * subject to change or being removed.
     */
    function isComponentConstructor(ctor) {
        if (!isFunction(ctor)) {
            return false;
        } // Fast path: LightningElement is part of the prototype chain of the constructor.
        if (ctor.prototype instanceof BaseLightningElement) {
            return true;
        } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
        // climb up the constructor prototype chain to check in case there are circular dependencies
        // to resolve.
        var current = ctor;
        do {
            if (isCircularModuleDependency(current)) {
                var circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end
                // of the proto chain, which must always be a valid base constructor.
                if (circularResolved === current) {
                    return true;
                }
                current = circularResolved;
            }
            if (current === BaseLightningElement) {
                return true;
            }
        } while (!isNull(current) && (current = getPrototypeOf(current))); // Finally return false if the LightningElement is not part of the prototype chain.
        return false;
    }
    function getComponentInternalDef(Ctor, name) {
        var def = CtorToDefMap.get(Ctor);
        if (isUndefined(def)) {
            if (isCircularModuleDependency(Ctor)) {
                var resolvedCtor = resolveCircularModuleDependency(Ctor);
                def = getComponentInternalDef(resolvedCtor); // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,
                // look up the definition in cache instead of re-resolving and recreating the def.
                CtorToDefMap.set(Ctor, def);
                return def;
            }
            if (!isComponentConstructor(Ctor)) {
                throw new TypeError(Ctor + " is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.");
            }
            var meta = getComponentRegisteredMeta(Ctor);
            if (isUndefined(meta)) {
                // TODO [#1295]: remove this workaround after refactoring tests
                meta = {
                    template: undefined,
                    name: Ctor.name
                };
            }
            def = createComponentDef(Ctor, meta, name || Ctor.name);
            CtorToDefMap.set(Ctor, def);
        }
        return def;
    }
    /**
     * EXPERIMENTAL: This function provides access to the component constructor,
     * given an HTMLElement. This API is subject to change or being removed.
     */
    function getComponentConstructor(elm) {
        var ctor = null;
        if (elm instanceof HTMLElement) {
            var vm = getAssociatedVMIfPresent(elm);
            if (!isUndefined(vm)) {
                ctor = vm.def.ctor;
            }
        }
        return ctor;
    } // Only set prototype for public methods and properties
    // No DOM Patching occurs here
    function setElementProto(elm, def) {
        setPrototypeOf(elm, def.bridge.prototype);
    }
    var lightingElementDef = {
        ctor: BaseLightningElement,
        name: BaseLightningElement.name,
        props: lightningBasedDescriptors,
        propsConfig: EmptyObject,
        methods: EmptyObject,
        wire: EmptyObject,
        bridge: BaseBridgeElement,
        template: defaultEmptyTemplate,
        render: BaseLightningElement.prototype.render
    };
    /**
     * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is
     * subject to change or being removed.
     */
    function getComponentDef(Ctor, subclassComponentName) {
        var def = getComponentInternalDef(Ctor, subclassComponentName); // From the internal def object, we need to extract the info that is useful
        // for some external services, e.g.: Locker Service, usually, all they care
        // is about the shape of the constructor, the internals of it are not relevant
        // because they don't have a way to mess with that.
        var ctor = def.ctor, name = def.name, props = def.props, propsConfig = def.propsConfig, methods = def.methods;
        var publicProps = {};
        for (var key in props) {
            // avoid leaking the reference to the public props descriptors
            publicProps[key] = {
                config: propsConfig[key] || 0,
                type: 'any',
                attr: getAttrNameFromPropName(key)
            };
        }
        var publicMethods = {};
        for (var key in methods) {
            // avoid leaking the reference to the public method descriptors
            publicMethods[key] = methods[key].value;
        }
        return {
            ctor: ctor,
            name: name,
            props: publicProps,
            methods: publicMethods
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var noop$1 = function () { return void 0; };
    function observeElementChildNodes(elm) {
        elm.$domManual$ = true;
    }
    function setElementShadowToken(elm, token) {
        elm.$shadowToken$ = token;
    }
    function updateNodeHook(oldVnode, vnode) {
        var text = vnode.text;
        if (oldVnode.text !== text) {
            /**
             * Compiler will never produce a text property that is not string
             */
            vnode.elm.nodeValue = text;
        }
    }
    function insertNodeHook(vnode, parentNode, referenceNode) {
        parentNode.insertBefore(vnode.elm, referenceNode);
    }
    function removeNodeHook(vnode, parentNode) {
        parentNode.removeChild(vnode.elm);
    }
    function createElmHook(vnode) {
        modEvents.create(vnode); // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
    }
    var LWCDOMMode;
    (function (LWCDOMMode) {
        LWCDOMMode["manual"] = "manual";
    })(LWCDOMMode || (LWCDOMMode = {}));
    function fallbackElmHook(vnode) {
        var owner = vnode.owner;
        var elm = vnode.elm;
        if (isTrue$1(useSyntheticShadow)) {
            var context = vnode.data.context;
            var shadowAttribute = owner.context.shadowAttribute;
            if (!isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {
                // this element will now accept any manual content inserted into it
                observeElementChildNodes(elm);
            } // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
        }
        if (false) {
            var context;
        }
    }
    function updateElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function insertCustomElmHook(vnode) {
        var vm = getAssociatedVM(vnode.elm);
        appendVM(vm);
    }
    function updateChildrenHook(oldVnode, vnode) {
        var children = vnode.children, owner = vnode.owner;
        var fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;
        runWithBoundaryProtection(owner, owner.owner, noop$1, function () {
            fn(vnode.elm, oldVnode.children, children);
        }, noop$1);
    }
    function allocateChildrenHook(vnode) {
        var vm = getAssociatedVM(vnode.elm); // A component with slots will re-render because:
        // 1- There is a change of the internal state.
        // 2- There is a change on the external api (ex: slots)
        //
        // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the
        // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children
        // in a reused VCustomElement, there won't be any slotted children.
        // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.
        //
        // In case #2, we will always get a fresh VCustomElement.
        var children = vnode.aChildren || vnode.children;
        vm.aChildren = children;
        if (isTrue$1(useSyntheticShadow)) {
            // slow path
            allocateInSlot(vm, children); // save the allocated children in case this vnode is reused.
            vnode.aChildren = children; // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
            vnode.children = EmptyArray;
        }
    }
    function createViewModelHook(vnode) {
        var elm = vnode.elm;
        if (!isUndefined(getAssociatedVMIfPresent(elm))) {
            // There is a possibility that a custom element is registered under tagName,
            // in which case, the initialization is already carry on, and there is nothing else
            // to do here since this hook is called right after invoking `document.createElement`.
            return;
        }
        var mode = vnode.mode, ctor = vnode.ctor, owner = vnode.owner;
        var def = getComponentInternalDef(ctor);
        setElementProto(elm, def);
        if (isTrue$1(useSyntheticShadow)) {
            var shadowAttribute = owner.context.shadowAttribute; // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
        }
        createVM(elm, def, {
            mode: mode,
            owner: owner,
            isRoot: false
        });
    }
    function createCustomElmHook(vnode) {
        modEvents.create(vnode); // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
    }
    function createChildrenHook(vnode) {
        var elm = vnode.elm, children = vnode.children;
        for (var j = 0; j < children.length; ++j) {
            var ch = children[j];
            if (ch != null) {
                ch.hook.create(ch);
                ch.hook.insert(ch, elm, null);
            }
        }
    }
    function rerenderCustomElmHook(vnode) {
        var vm = getAssociatedVM(vnode.elm);
        rerenderVM(vm);
    }
    function updateCustomElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function removeElmHook(vnode) {
        // this method only needs to search on child vnodes from template
        // to trigger the remove hook just in case some of those children
        // are custom elements.
        var children = vnode.children, elm = vnode.elm;
        for (var j = 0, len = children.length; j < len; ++j) {
            var ch = children[j];
            if (!isNull(ch)) {
                ch.hook.remove(ch, elm);
            }
        }
    }
    function removeCustomElmHook(vnode) {
        // for custom elements we don't have to go recursively because the removeVM routine
        // will take care of disconnecting any child VM attached to its shadow as well.
        removeVM(getAssociatedVM(vnode.elm));
    } // Using a WeakMap instead of a WeakSet because this one works in IE11 :(
    var FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration
    // in a template, and will require a more complex diffing algo.
    function markAsDynamicChildren(children) {
        FromIteration.set(children, 1);
    }
    function hasDynamicChildren(children) {
        return FromIteration.has(children);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CHAR_S = 115;
    var CHAR_V = 118;
    var CHAR_G = 103;
    var NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
    var SymbolIterator = Symbol.iterator;
    var TextHook = {
        create: function (vnode) {
            vnode.elm = document.createTextNode(vnode.text);
            linkNodeToShadow(vnode);
        },
        update: updateNodeHook,
        insert: insertNodeHook,
        move: insertNodeHook,
        remove: removeNodeHook
    }; // insert is called after update, which is used somewhere else (via a module)
    // to mark the vm as inserted, that means we cannot use update as the main channel
    // to rehydrate when dirty, because sometimes the element is not inserted just yet,
    // which breaks some invariants. For that reason, we have the following for any
    // Custom Element that is inserted via a template.
    var ElementHook = {
        create: function (vnode) {
            var data = vnode.data, sel = vnode.sel, clonedElement = vnode.clonedElement;
            var ns = data.ns; // TODO [#1364]: supporting the ability to inject a cloned StyleElement via a vnode this is
            // used for style tags for native shadow
            if (isUndefined(clonedElement)) {
                vnode.elm = isUndefined(ns) ? document.createElement(sel) : document.createElementNS(ns, sel);
            }
            else {
                vnode.elm = clonedElement;
            }
            linkNodeToShadow(vnode);
            fallbackElmHook(vnode);
            createElmHook(vnode);
        },
        update: function (oldVnode, vnode) {
            updateElmHook(oldVnode, vnode);
            updateChildrenHook(oldVnode, vnode);
        },
        insert: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
            createChildrenHook(vnode);
        },
        move: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: function (vnode, parentNode) {
            removeNodeHook(vnode, parentNode);
            removeElmHook(vnode);
        }
    };
    var CustomElementHook = {
        create: function (vnode) {
            var sel = vnode.sel;
            vnode.elm = document.createElement(sel);
            linkNodeToShadow(vnode);
            createViewModelHook(vnode);
            allocateChildrenHook(vnode);
            createCustomElmHook(vnode);
        },
        update: function (oldVnode, vnode) {
            updateCustomElmHook(oldVnode, vnode); // in fallback mode, the allocation will always set children to
            // empty and delegate the real allocation to the slot elements
            allocateChildrenHook(vnode); // in fallback mode, the children will be always empty, so, nothing
            // will happen, but in native, it does allocate the light dom
            updateChildrenHook(oldVnode, vnode); // this will update the shadowRoot
            rerenderCustomElmHook(vnode);
        },
        insert: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
            var vm = getAssociatedVM(vnode.elm);
            runConnectedCallback(vm);
            createChildrenHook(vnode);
            insertCustomElmHook(vnode);
        },
        move: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: function (vnode, parentNode) {
            removeNodeHook(vnode, parentNode);
            removeCustomElmHook(vnode);
        }
    };
    function linkNodeToShadow(vnode) {
        // TODO [#1164]: this should eventually be done by the polyfill directly
        vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;
    } // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element
    function addNS(vnode) {
        var data = vnode.data, children = vnode.children, sel = vnode.sel;
        data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`
        if (isArray$1(children) && sel !== 'foreignObject') {
            for (var j = 0, n = children.length; j < n; ++j) {
                var childNode = children[j];
                if (childNode != null && childNode.hook === ElementHook) {
                    addNS(childNode);
                }
            }
        }
    }
    function addVNodeToChildLWC(vnode) {
        ArrayPush.call(getVMBeingRendered().velements, vnode);
    } // [h]tml node
    function h(sel, data, children) {
        var vmBeingRendered = getVMBeingRendered();
        var key = data.key;
        var text, elm;
        var vnode = {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: ElementHook,
            owner: vmBeingRendered
        };
        if (sel.length === 3 && StringCharCodeAt.call(sel, 0) === CHAR_S && StringCharCodeAt.call(sel, 1) === CHAR_V && StringCharCodeAt.call(sel, 2) === CHAR_G) {
            addNS(vnode);
        }
        return vnode;
    } // [t]ab[i]ndex function
    function ti(value) {
        // if value is greater than 0, we normalize to 0
        // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
        // If value is less than -1, we don't care
        var shouldNormalize = value > 0 && !(isTrue$1(value) || isFalse$1(value));
        return shouldNormalize ? 0 : value;
    } // [s]lot element node
    function s(slotName, data, children, slotset) {
        if (!isUndefined(slotset) && !isUndefined(slotset[slotName]) && slotset[slotName].length !== 0) {
            children = slotset[slotName];
        }
        var vnode = h('slot', data, children);
        if (useSyntheticShadow) {
            // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
            sc(children);
        }
        return vnode;
    } // [c]ustom element node
    function c(sel, Ctor, data, children) {
        if (children === void 0) { children = EmptyArray; }
        var vmBeingRendered = getVMBeingRendered();
        var key = data.key;
        var text, elm;
        var vnode = {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: CustomElementHook,
            ctor: Ctor,
            owner: vmBeingRendered,
            mode: 'open'
        };
        addVNodeToChildLWC(vnode);
        return vnode;
    } // [i]terable node
    function i(iterable, factory) {
        var list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(list);
        if (isUndefined(iterable) || iterable === null) {
            return list;
        }
        var iterator = iterable[SymbolIterator]();
        var next = iterator.next();
        var j = 0;
        var value = next.value, last = next.done;
        while (last === false) {
            // implementing a look-back-approach because we need to know if the element is the last
            next = iterator.next();
            last = next.done; // template factory logic based on the previous collected value
            var vnode = factory(value, j, j === 0, last);
            if (isArray$1(vnode)) {
                ArrayPush.apply(list, vnode);
            }
            else {
                ArrayPush.call(list, vnode);
            }
            j += 1;
            value = next.value;
        }
        return list;
    }
    /**
     * [f]lattening
     */
    function f(items) {
        var len = items.length;
        var flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(flattened);
        for (var j = 0; j < len; j += 1) {
            var item = items[j];
            if (isArray$1(item)) {
                ArrayPush.apply(flattened, item);
            }
            else {
                ArrayPush.call(flattened, item);
            }
        }
        return flattened;
    } // [t]ext node
    function t(text) {
        var data = EmptyObject;
        var sel, children, key, elm;
        return {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: TextHook,
            owner: getVMBeingRendered()
        };
    } // [d]ynamic value to produce a text vnode
    function d(value) {
        if (value == null) {
            return null;
        }
        return t(value);
    } // [b]ind function
    function b(fn) {
        var vmBeingRendered = getVMBeingRendered();
        if (isNull(vmBeingRendered)) {
            throw new Error();
        }
        var vm = vmBeingRendered;
        return function (event) {
            invokeEventListener(vm, fn, vm.component, event);
        };
    } // [k]ey function
    function k(compilerKey, obj) {
        switch (typeof obj) {
            case 'number':
            case 'string':
                return compilerKey + ':' + obj;
        }
    } // [g]lobal [id] function
    function gid(id) {
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined(id) || id === '') {
            return id;
        } // We remove attributes when they are assigned a value of null
        if (isNull(id)) {
            return null;
        }
        return id + "-" + vmBeingRendered.idx;
    } // [f]ragment [id] function
    function fid(url) {
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined(url) || url === '') {
            return url;
        } // We remove attributes when they are assigned a value of null
        if (isNull(url)) {
            return null;
        } // Apply transformation only for fragment-only-urls
        if (/^#/.test(url)) {
            return url + "-" + vmBeingRendered.idx;
        }
        return url;
    }
    /**
     * Map to store an index value assigned to any dynamic component reference ingested
     * by dc() api. This allows us to generate a unique unique per template per dynamic
     * component reference to avoid diffing algo mismatches.
     */
    var DynamicImportedComponentMap = new Map();
    var dynamicImportedComponentCounter = 0;
    /**
     * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`
     */
    function dc(sel, Ctor, data, children) {
        if (Ctor == null) {
            return null;
        }
        if (!isComponentConstructor(Ctor)) {
            throw new Error("Invalid LWC Constructor " + toString(Ctor) + " for custom element <" + sel + ">.");
        }
        var idx = DynamicImportedComponentMap.get(Ctor);
        if (isUndefined(idx)) {
            idx = dynamicImportedComponentCounter++;
            DynamicImportedComponentMap.set(Ctor, idx);
        } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo
        // to identify different constructors as vnodes with different keys to avoid reusing the
        // element used for previous constructors.
        data.key = "dc:" + idx + ":" + data.key;
        return c(sel, Ctor, data, children);
    }
    /**
     * slow children collection marking mechanism. this API allows the compiler to signal
     * to the engine that a particular collection of children must be diffed using the slow
     * algo based on keys due to the nature of the list. E.g.:
     *
     *   - slot element's children: the content of the slot has to be dynamic when in synthetic
     *                              shadow mode because the `vnode.children` might be the slotted
     *                              content vs default content, in which case the size and the
     *                              keys are not matching.
     *   - children that contain dynamic components
     *   - children that are produced by iteration
     *
     */
    function sc(vnodes) {
        // choose to use the snabbdom virtual dom diffing algo instead of our
        // static dummy algo.
        markAsDynamicChildren(vnodes);
        return vnodes;
    }
    var api$1 = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        h: h,
        ti: ti,
        s: s,
        c: c,
        i: i,
        f: f,
        t: t,
        d: d,
        b: b,
        k: k,
        gid: gid,
        fid: fid,
        dc: dc,
        sc: sc
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CachedStyleFragments = create(null);
    function createStyleElement(styleContent) {
        var elm = document.createElement('style');
        elm.type = 'text/css';
        elm.textContent = styleContent;
        return elm;
    }
    function getCachedStyleElement(styleContent) {
        var fragment = CachedStyleFragments[styleContent];
        if (isUndefined(fragment)) {
            fragment = document.createDocumentFragment();
            var styleElm = createStyleElement(styleContent);
            fragment.appendChild(styleElm);
            CachedStyleFragments[styleContent] = fragment;
        }
        return fragment.cloneNode(true).firstChild;
    }
    var globalStyleParent = document.head || document.body || document;
    var InsertedGlobalStyleContent = create(null);
    function insertGlobalStyle(styleContent) {
        // inserts the global style when needed, otherwise does nothing
        if (isUndefined(InsertedGlobalStyleContent[styleContent])) {
            InsertedGlobalStyleContent[styleContent] = true;
            var elm = createStyleElement(styleContent);
            globalStyleParent.appendChild(elm);
        }
    }
    function createStyleVNode(elm) {
        var vnode = h('style', {
            key: 'style'
        }, EmptyArray); // TODO [#1364]: supporting the ability to inject a cloned StyleElement
        // forcing the diffing algo to use the cloned style for native shadow
        vnode.clonedElement = elm;
        return vnode;
    }
    /**
     * Reset the styling token applied to the host element.
     */
    function resetStyleAttributes(vm) {
        var context = vm.context, elm = vm.elm; // Remove the style attribute currently applied to the host element.
        var oldHostAttribute = context.hostAttribute;
        if (!isUndefined(oldHostAttribute)) {
            removeAttribute.call(elm, oldHostAttribute);
        } // Reset the scoping attributes associated to the context.
        context.hostAttribute = context.shadowAttribute = undefined;
    }
    /**
     * Apply/Update the styling token applied to the host element.
     */
    function applyStyleAttributes(vm, hostAttribute, shadowAttribute) {
        var context = vm.context, elm = vm.elm; // Remove the style attribute currently applied to the host element.
        setAttribute.call(elm, hostAttribute, '');
        context.hostAttribute = hostAttribute;
        context.shadowAttribute = shadowAttribute;
    }
    function collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {
        forEach.call(stylesheets, function (sheet) {
            if (isArray$1(sheet)) {
                collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);
            }
            else {
                aggregatorFn(sheet(hostSelector, shadowSelector, isNative));
            }
        });
    }
    function evaluateCSS(stylesheets, hostAttribute, shadowAttribute) {
        if (useSyntheticShadow) {
            var hostSelector = "[" + hostAttribute + "]";
            var shadowSelector = "[" + shadowAttribute + "]";
            collectStylesheets(stylesheets, hostSelector, shadowSelector, false, function (textContent) {
                insertGlobalStyle(textContent);
            });
            return null;
        }
        else {
            // Native shadow in place, we need to act accordingly by using the `:host` selector, and an
            // empty shadow selector since it is not really needed.
            var buffer_1 = '';
            collectStylesheets(stylesheets, emptyString, emptyString, true, function (textContent) {
                buffer_1 += textContent;
            });
            return createStyleVNode(getCachedStyleElement(buffer_1));
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var GlobalMeasurementPhase;
    (function (GlobalMeasurementPhase) {
        GlobalMeasurementPhase["REHYDRATE"] = "lwc-rehydrate";
        GlobalMeasurementPhase["HYDRATE"] = "lwc-hydrate";
    })(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
    var isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    function getMarkName(phase, vm) {
        // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
        // the right measures for components that are recursive.
        return getComponentTag(vm) + " - " + phase + " - " + vm.idx;
    }
    function start(markName) {
        performance.mark(markName);
    }
    function end(measureName, markName) {
        performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.
        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
        performance.clearMarks(markName);
        performance.clearMarks(measureName);
    }
    function noop$2() {
        /* do nothing */
    }
    var startGlobalMeasure = !isUserTimingSupported ? noop$2 : function (phase, vm) {
        var markName = isUndefined(vm) ? phase : getMarkName(phase, vm);
        start(markName);
    };
    var endGlobalMeasure = !isUserTimingSupported ? noop$2 : function (phase, vm) {
        var markName = isUndefined(vm) ? phase : getMarkName(phase, vm);
        end(phase, markName);
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isUpdatingTemplate = false;
    var vmBeingRendered = null;
    function getVMBeingRendered() {
        return vmBeingRendered;
    }
    function setVMBeingRendered(vm) {
        vmBeingRendered = vm;
    }
    function validateSlots(vm, html) {
        {
            // this method should never leak to prod
            throw new ReferenceError();
        }
    }
    function validateFields(vm, html) {
        {
            // this method should never leak to prod
            throw new ReferenceError();
        }
    }
    function evaluateTemplate(vm, html) {
        var isUpdatingTemplateInception = isUpdatingTemplate;
        var vmOfTemplateBeingUpdatedInception = vmBeingRendered;
        var vnodes = [];
        runWithBoundaryProtection(vm, vm.owner, function () {
            // pre
            vmBeingRendered = vm;
        }, function () {
            // job
            var component = vm.component, context = vm.context, cmpSlots = vm.cmpSlots, cmpTemplate = vm.cmpTemplate, tro = vm.tro;
            tro.observe(function () {
                // reset the cache memoizer for template when needed
                if (html !== cmpTemplate) {
                    // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)
                    if (!isUndefined(cmpTemplate)) {
                        // It is important to reset the content to avoid reusing similar elements generated from a different
                        // template, because they could have similar IDs, and snabbdom just rely on the IDs.
                        resetShadowRoot(vm);
                    } // Check that the template was built by the compiler
                    if (isUndefined(html) || !isTemplateRegistered(html)) {
                        throw new TypeError("Invalid template returned by the render() method on " + vm + ". It must return an imported template (e.g.: `import html from \"./" + vm.def.name + ".html\"`), instead, it has returned: " + toString(html) + ".");
                    }
                    vm.cmpTemplate = html; // Populate context with template information
                    context.tplCache = create(null);
                    resetStyleAttributes(vm);
                    var stylesheets = html.stylesheets, stylesheetTokens = html.stylesheetTokens;
                    if (isUndefined(stylesheets) || stylesheets.length === 0) {
                        context.styleVNode = null;
                    }
                    else if (!isUndefined(stylesheetTokens)) {
                        var hostAttribute = stylesheetTokens.hostAttribute, shadowAttribute = stylesheetTokens.shadowAttribute;
                        applyStyleAttributes(vm, hostAttribute, shadowAttribute); // Caching style vnode so it can be reused on every render
                        context.styleVNode = evaluateCSS(stylesheets, hostAttribute, shadowAttribute);
                    }
                    if ("production" !== 'production') {
                        // one time operation for any new template returned by render()
                        // so we can warn if the template is attempting to use a binding
                        // that is not provided by the component instance.
                        validateFields(vm, html);
                    }
                }
                if ("production" !== 'production') {
                    assert.isTrue(isObject$1(context.tplCache), "vm.context.tplCache must be an object associated to " + cmpTemplate + "."); // validating slots in every rendering since the allocated content might change over time
                    validateSlots(vm, html);
                } // right before producing the vnodes, we clear up all internal references
                // to custom elements from the template.
                vm.velements = []; // Set the global flag that template is being updated
                isUpdatingTemplate = true;
                vnodes = html.call(undefined, api$1, component, cmpSlots, context.tplCache);
                var styleVNode = context.styleVNode;
                if (!isNull(styleVNode)) {
                    ArrayUnshift$1.call(vnodes, styleVNode);
                }
            });
        }, function () {
            // post
            isUpdatingTemplate = isUpdatingTemplateInception;
            vmBeingRendered = vmOfTemplateBeingUpdatedInception;
        });
        return vnodes;
    }
    var vmBeingConstructed = null;
    function isBeingConstructed(vm) {
        return vmBeingConstructed === vm;
    }
    var noop$3 = function () { return void 0; };
    function invokeComponentCallback(vm, fn, args) {
        var component = vm.component, callHook = vm.callHook, owner = vm.owner;
        var result;
        runWithBoundaryProtection(vm, owner, noop$3, function () {
            // job
            result = callHook(component, fn, args);
        }, noop$3);
        return result;
    }
    function invokeComponentConstructor(vm, Ctor) {
        var vmBeingConstructedInception = vmBeingConstructed;
        var error;
        vmBeingConstructed = vm;
        /**
         * Constructors don't need to be wrapped with a boundary because for root elements
         * it should throw, while elements from template are already wrapped by a boundary
         * associated to the diffing algo.
         */
        try {
            // job
            var result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using
            // the "instanceof" operator would not work here since Locker Service provides its own
            // implementation of LightningElement, so we indirectly check if the base constructor is
            // invoked by accessing the component on the vm.
            if (vmBeingConstructed.component !== result) {
                throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
            }
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            vmBeingConstructed = vmBeingConstructedInception;
            if (!isUndefined(error)) {
                error.wcStack = getErrorComponentStack(vm); // re-throwing the original error annotated after restoring the context
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
    }
    function invokeComponentRenderMethod(vm) {
        var render = vm.def.render, callHook = vm.callHook, component = vm.component, owner = vm.owner;
        var vmBeingRenderedInception = getVMBeingRendered();
        var html;
        var renderInvocationSuccessful = false;
        runWithBoundaryProtection(vm, owner, function () {
            setVMBeingRendered(vm);
        }, function () {
            // job
            vm.tro.observe(function () {
                html = callHook(component, render);
                renderInvocationSuccessful = true;
            });
        }, function () {
            setVMBeingRendered(vmBeingRenderedInception);
        }); // If render() invocation failed, process errorCallback in boundary and return an empty template
        return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
    }
    function invokeComponentRenderedCallback(vm) {
        var renderedCallback = vm.def.renderedCallback, component = vm.component, callHook = vm.callHook, owner = vm.owner;
        if (!isUndefined(renderedCallback)) {
            runWithBoundaryProtection(vm, owner, function () {
            }, function () {
                // job
                callHook(component, renderedCallback);
            }, function () {
            });
        }
    }
    function invokeEventListener(vm, fn, thisValue, event) {
        var callHook = vm.callHook, owner = vm.owner;
        runWithBoundaryProtection(vm, owner, noop$3, function () {
            // job
            if ("production" !== 'production') {
                assert.isTrue(isFunction(fn), "Invalid event handler for event '" + event.type + "' on " + vm + ".");
            }
            callHook(thisValue, fn, [event]);
        }, noop$3);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var signedComponentToMetaMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerComponent(Ctor, _b) {
        var name = _b.name, template = _b.tmpl;
        signedComponentToMetaMap.set(Ctor, {
            name: name,
            template: template
        }); // chaining this method as a way to wrap existing
        // assignment of component constructor easily, without too much transformation
        return Ctor;
    }
    function getComponentRegisteredMeta(Ctor) {
        return signedComponentToMetaMap.get(Ctor);
    }
    function createComponent(uninitializedVm, Ctor) {
        // create the component instance
        invokeComponentConstructor(uninitializedVm, Ctor);
        var initializedVm = uninitializedVm;
        if (isUndefined(initializedVm.component)) {
            throw new ReferenceError("Invalid construction for " + Ctor + ", you must extend LightningElement.");
        }
    }
    function getTemplateReactiveObserver(vm) {
        return new ReactiveObserver(function () {
            var isDirty = vm.isDirty;
            if (isFalse$1(isDirty)) {
                markComponentAsDirty(vm);
                scheduleRehydration(vm);
            }
        });
    }
    function renderComponent(vm) {
        vm.tro.reset();
        var vnodes = invokeComponentRenderMethod(vm);
        vm.isDirty = false;
        vm.isScheduled = false;
        return vnodes;
    }
    function markComponentAsDirty(vm) {
        vm.isDirty = true;
    }
    var cmpEventListenerMap = new WeakMap();
    function getWrappedComponentsListener(vm, listener) {
        if (!isFunction(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        var wrappedListener = cmpEventListenerMap.get(listener);
        if (isUndefined(wrappedListener)) {
            wrappedListener = function (event) {
                invokeEventListener(vm, listener, undefined, event);
            };
            cmpEventListenerMap.set(listener, wrappedListener);
        }
        return wrappedListener;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var Services = create(null);
    var hooks = ['rendered', 'connected', 'disconnected'];
    /**
     * EXPERIMENTAL: This function allows for the registration of "services"
     * in LWC by exposing hooks into the component life-cycle. This API is
     * subject to change or being removed.
     */
    function register(service) {
        for (var i_11 = 0; i_11 < hooks.length; ++i_11) {
            var hookName = hooks[i_11];
            if (hookName in service) {
                var l = Services[hookName];
                if (isUndefined(l)) {
                    Services[hookName] = l = [];
                }
                ArrayPush.call(l, service[hookName]);
            }
        }
    }
    function invokeServiceHook(vm, cbs) {
        var component = vm.component, data = vm.data, def = vm.def, context = vm.context;
        for (var i_12 = 0, len = cbs.length; i_12 < len; ++i_12) {
            cbs[i_12].call(undefined, component, data, def, context);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var VMState;
    (function (VMState) {
        VMState[VMState["created"] = 0] = "created";
        VMState[VMState["connected"] = 1] = "connected";
        VMState[VMState["disconnected"] = 2] = "disconnected";
    })(VMState || (VMState = {}));
    var idx = 0;
    /** The internal slot used to associate different objects the engine manipulates with the VM */
    var ViewModelReflection = createHiddenField('ViewModel', 'engine');
    function callHook(cmp, fn, args) {
        if (args === void 0) { args = []; }
        return fn.apply(cmp, args);
    }
    function setHook(cmp, prop, newValue) {
        cmp[prop] = newValue;
    }
    function getHook(cmp, prop) {
        return cmp[prop];
    }
    function rerenderVM(vm) {
        rehydrate(vm);
    }
    function connectRootElement(elm) {
        var vm = getAssociatedVM(elm);
        startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm); // Usually means moving the element from one place to another, which is observable via
        // life-cycle hooks.
        if (vm.state === VMState.connected) {
            disconnectedRootElement(elm);
        }
        runConnectedCallback(vm);
        rehydrate(vm);
        endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);
    }
    function disconnectedRootElement(elm) {
        var vm = getAssociatedVM(elm);
        resetComponentStateWhenRemoved(vm);
    }
    function appendVM(vm) {
        rehydrate(vm);
    } // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.
    function resetComponentStateWhenRemoved(vm) {
        var state = vm.state;
        if (state !== VMState.disconnected) {
            var oar = vm.oar, tro = vm.tro; // Making sure that any observing record will not trigger the rehydrated on this vm
            tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked
            for (var key in oar) {
                oar[key].reset();
            }
            runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
            runShadowChildNodesDisconnectedCallback(vm);
            runLightChildNodesDisconnectedCallback(vm);
        }
    } // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.
    function removeVM(vm) {
        resetComponentStateWhenRemoved(vm);
    }
    function createVM(elm, def, options) {
        var isRoot = options.isRoot, mode = options.mode, owner = options.owner;
        idx += 1;
        var uninitializedVm = {
            // component creation index is defined once, and never reset, it can
            // be preserved from one insertion to another without any issue
            idx: idx,
            state: VMState.created,
            isScheduled: false,
            isDirty: true,
            isRoot: isTrue$1(isRoot),
            mode: mode,
            def: def,
            owner: owner,
            elm: elm,
            data: EmptyObject,
            context: create(null),
            cmpProps: create(null),
            cmpFields: create(null),
            cmpSlots: useSyntheticShadow ? create(null) : undefined,
            callHook: callHook,
            setHook: setHook,
            getHook: getHook,
            children: EmptyArray,
            aChildren: EmptyArray,
            velements: EmptyArray,
            // Perf optimization to preserve the shape of this obj
            cmpTemplate: undefined,
            component: undefined,
            cmpRoot: undefined,
            tro: undefined,
            oar: undefined
        };
        createComponent(uninitializedVm, def.ctor); // link component to the wire service
        var initializedVm = uninitializedVm; // initializing the wire decorator per instance only when really needed
        if (hasWireAdapters(initializedVm)) {
            installWireAdapters(initializedVm);
        }
        return initializedVm;
    }
    function associateVM(obj, vm) {
        setHiddenField(obj, ViewModelReflection, vm);
    }
    function getAssociatedVM(obj) {
        var vm = getHiddenField(obj, ViewModelReflection);
        return vm;
    }
    function getAssociatedVMIfPresent(obj) {
        var maybeVm = getHiddenField(obj, ViewModelReflection);
        return maybeVm;
    }
    function rehydrate(vm) {
        if (isTrue$1(vm.isDirty)) {
            var children = renderComponent(vm);
            patchShadowRoot(vm, children);
        }
    }
    function patchShadowRoot(vm, newCh) {
        var cmpRoot = vm.cmpRoot, oldCh = vm.children;
        vm.children = newCh; // caching the new children collection
        if (newCh.length > 0 || oldCh.length > 0) {
            // patch function mutates vnodes by adding the element reference,
            // however, if patching fails it contains partial changes.
            if (oldCh !== newCh) {
                var fn_1 = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;
                runWithBoundaryProtection(vm, vm, function () {
                }, function () {
                    // job
                    fn_1(cmpRoot, oldCh, newCh);
                }, function () {
                });
            }
        }
        if (vm.state === VMState.connected) {
            // If the element is connected, that means connectedCallback was already issued, and
            // any successive rendering should finish with the call to renderedCallback, otherwise
            // the connectedCallback will take care of calling it in the right order at the end of
            // the current rehydration process.
            runRenderedCallback(vm);
        }
    }
    function runRenderedCallback(vm) {
        var rendered = Services.rendered;
        if (rendered) {
            invokeServiceHook(vm, rendered);
        }
        invokeComponentRenderedCallback(vm);
    }
    var rehydrateQueue = [];
    function flushRehydrationQueue() {
        startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
        var vms = rehydrateQueue.sort(function (a, b) { return a.idx - b.idx; });
        rehydrateQueue = []; // reset to a new queue
        for (var i_13 = 0, len = vms.length; i_13 < len; i_13 += 1) {
            var vm = vms[i_13];
            try {
                rehydrate(vm);
            }
            catch (error) {
                if (i_13 + 1 < len) {
                    // pieces of the queue are still pending to be rehydrated, those should have priority
                    if (rehydrateQueue.length === 0) {
                        addCallbackToNextTick(flushRehydrationQueue);
                    }
                    ArrayUnshift$1.apply(rehydrateQueue, ArraySlice$1.call(vms, i_13 + 1));
                } // we need to end the measure before throwing.
                endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is
                // already scheduled, it should continue patching the rest.
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
        endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
    }
    function runConnectedCallback(vm) {
        var state = vm.state;
        if (state === VMState.connected) {
            return; // nothing to do since it was already connected
        }
        vm.state = VMState.connected; // reporting connection
        var connected = Services.connected;
        if (connected) {
            invokeServiceHook(vm, connected);
        }
        if (hasWireAdapters(vm)) {
            connectWireAdapters(vm);
        }
        var connectedCallback = vm.def.connectedCallback;
        if (!isUndefined(connectedCallback)) {
            invokeComponentCallback(vm, connectedCallback);
        }
    }
    function hasWireAdapters(vm) {
        return getOwnPropertyNames(vm.def.wire).length > 0;
    }
    function runDisconnectedCallback(vm) {
        if (isFalse$1(vm.isDirty)) {
            // this guarantees that if the component is reused/reinserted,
            // it will be re-rendered because we are disconnecting the reactivity
            // linking, so mutations are not automatically reflected on the state
            // of disconnected components.
            vm.isDirty = true;
        }
        vm.state = VMState.disconnected; // reporting disconnection
        var disconnected = Services.disconnected;
        if (disconnected) {
            invokeServiceHook(vm, disconnected);
        }
        if (hasWireAdapters(vm)) {
            disconnectWireAdapters(vm);
        }
        var disconnectedCallback = vm.def.disconnectedCallback;
        if (!isUndefined(disconnectedCallback)) {
            invokeComponentCallback(vm, disconnectedCallback);
        }
    }
    function runShadowChildNodesDisconnectedCallback(vm) {
        var vCustomElementCollection = vm.velements; // reporting disconnection for every child in inverse order since they are inserted in reserved order
        for (var i_14 = vCustomElementCollection.length - 1; i_14 >= 0; i_14 -= 1) {
            var elm = vCustomElementCollection[i_14].elm; // There are two cases where the element could be undefined:
            // * when there is an error during the construction phase, and an
            //   error boundary picks it, there is a possibility that the VCustomElement
            //   is not properly initialized, and therefore is should be ignored.
            // * when slotted custom element is not used by the element where it is slotted
            //   into it, as a result, the custom element was never initialized.
            if (!isUndefined(elm)) {
                var childVM = getAssociatedVM(elm);
                resetComponentStateWhenRemoved(childVM);
            }
        }
    }
    function runLightChildNodesDisconnectedCallback(vm) {
        var adoptedChildren = vm.aChildren;
        recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     */
    function recursivelyDisconnectChildren(vnodes) {
        for (var i_15 = 0, len = vnodes.length; i_15 < len; i_15 += 1) {
            var vnode = vnodes[i_15];
            if (!isNull(vnode) && isArray$1(vnode.children) && !isUndefined(vnode.elm)) {
                // vnode is a VElement with children
                if (isUndefined(vnode.ctor)) {
                    // it is a VElement, just keep looking (recursively)
                    recursivelyDisconnectChildren(vnode.children);
                }
                else {
                    // it is a VCustomElement, disconnect it and ignore its children
                    resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));
                }
            }
        }
    } // This is a super optimized mechanism to remove the content of the shadowRoot
    // without having to go into snabbdom. Especially useful when the reset is a consequence
    // of an error, in which case the children VNodes might not be representing the current
    // state of the DOM
    function resetShadowRoot(vm) {
        vm.children = EmptyArray;
        ShadowRootInnerHTMLSetter.call(vm.cmpRoot, ''); // disconnecting any known custom element inside the shadow of the this vm
        runShadowChildNodesDisconnectedCallback(vm);
    }
    function scheduleRehydration(vm) {
        if (!vm.isScheduled) {
            vm.isScheduled = true;
            if (rehydrateQueue.length === 0) {
                addCallbackToNextTick(flushRehydrationQueue);
            }
            ArrayPush.call(rehydrateQueue, vm);
        }
    }
    function getErrorBoundaryVM(vm) {
        var currentVm = vm;
        while (!isNull(currentVm)) {
            if (!isUndefined(currentVm.def.errorCallback)) {
                return currentVm;
            }
            currentVm = currentVm.owner;
        }
    }
    /**
     * EXPERIMENTAL: This function detects whether or not a Node is
     * controlled by a LWC template. This API is subject to
     * change or being removed.
     */
    function isNodeFromTemplate(node) {
        if (isFalse$1(node instanceof Node)) {
            return false;
        } // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker
        if (node instanceof ShadowRoot) {
            return false;
        }
        if (useSyntheticShadow) {
            // TODO [#1252]: old behavior that is still used by some pieces of the platform, specifically, nodes inserted
            // manually on places where `lwc:dom="manual"` directive is not used, will be considered global elements.
            if (isUndefined(node.$shadowResolver$)) {
                return false;
            }
        }
        var root = node.getRootNode();
        return root instanceof ShadowRoot;
    } // slow path routine
    // NOTE: we should probably more this routine to the synthetic shadow folder
    // and get the allocation to be cached by in the elm instead of in the VM
    function allocateInSlot(vm, children) {
        var oldSlots = vm.cmpSlots;
        var cmpSlots = vm.cmpSlots = create(null);
        for (var i_16 = 0, len = children.length; i_16 < len; i_16 += 1) {
            var vnode = children[i_16];
            if (isNull(vnode)) {
                continue;
            }
            var data = vnode.data;
            var slotName = data.attrs && data.attrs.slot || '';
            var vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot
            // which might have similar keys. Each vnode will always have a key that
            // starts with a numeric character from compiler. In this case, we add a unique
            // notation for slotted vnodes keys, e.g.: `@foo:1:1`
            vnode.key = "@" + slotName + ":" + vnode.key;
            ArrayPush.call(vnodes, vnode);
        }
        if (isFalse$1(vm.isDirty)) {
            // We need to determine if the old allocation is really different from the new one
            // and mark the vm as dirty
            var oldKeys = keys(oldSlots);
            if (oldKeys.length !== keys(cmpSlots).length) {
                markComponentAsDirty(vm);
                return;
            }
            for (var i_17 = 0, len = oldKeys.length; i_17 < len; i_17 += 1) {
                var key = oldKeys[i_17];
                if (isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
                    markComponentAsDirty(vm);
                    return;
                }
                var oldVNodes = oldSlots[key];
                var vnodes = cmpSlots[key];
                for (var j = 0, a = cmpSlots[key].length; j < a; j += 1) {
                    if (oldVNodes[j] !== vnodes[j]) {
                        markComponentAsDirty(vm);
                        return;
                    }
                }
            }
        }
    }
    function runWithBoundaryProtection(vm, owner, pre, job, post) {
        var error;
        pre();
        try {
            job();
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            post();
            if (!isUndefined(error)) {
                error.wcStack = error.wcStack || getErrorComponentStack(vm);
                var errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);
                if (isUndefined(errorBoundaryVm)) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
                resetShadowRoot(vm); // remove offenders
                var errorCallback = errorBoundaryVm.def.errorCallback;
                invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
            }
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ConnectingSlot = createHiddenField('connecting', 'engine');
    var DisconnectingSlot = createHiddenField('disconnecting', 'engine');
    function callNodeSlot(node, slot) {
        var fn = getHiddenField(node, slot);
        if (!isUndefined(fn)) {
            fn(node);
        }
        return node; // for convenience
    } // Monkey patching Node methods to be able to detect the insertions and removal of root elements
    // created via createElement.
    assign(Node.prototype, {
        appendChild: function (newChild) {
            var appendedNode = appendChild.call(this, newChild);
            return callNodeSlot(appendedNode, ConnectingSlot);
        },
        insertBefore: function (newChild, referenceNode) {
            var insertedNode = insertBefore.call(this, newChild, referenceNode);
            return callNodeSlot(insertedNode, ConnectingSlot);
        },
        removeChild: function (oldChild) {
            var removedNode = removeChild.call(this, oldChild);
            return callNodeSlot(removedNode, DisconnectingSlot);
        },
        replaceChild: function (newChild, oldChild) {
            var replacedNode = replaceChild.call(this, newChild, oldChild);
            callNodeSlot(replacedNode, DisconnectingSlot);
            callNodeSlot(newChild, ConnectingSlot);
            return replacedNode;
        }
    });
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
     * difference that in the options, you can pass the `is` property set to a Constructor instead of
     * just a string value. The intent is to allow the creation of an element controlled by LWC without
     * having to register the element as a custom element.
     *
     * @example
     * ```
     * const el = createElement('x-foo', { is: FooCtor });
     * ```
     */
    function createElement(sel, options) {
        if (!isObject$1(options) || isNull(options)) {
            throw new TypeError("\"createElement\" function expects an object as second parameter but received \"" + toString(options) + "\".");
        }
        var Ctor = options.is;
        if (!isFunction(Ctor)) {
            throw new TypeError("\"createElement\" function expects a \"is\" option with a valid component constructor.");
        }
        var element = document.createElement(sel); // There is a possibility that a custom element is registered under tagName, in which case, the
        // initialization is already carry on, and there is nothing else to do here.
        if (!isUndefined(getAssociatedVMIfPresent(element))) {
            return element;
        }
        var def = getComponentInternalDef(Ctor);
        setElementProto(element, def);
        createVM(element, def, {
            mode: options.mode !== 'closed' ? 'open' : 'closed',
            owner: null,
            isRoot: true
        });
        setHiddenField(element, ConnectingSlot, connectRootElement);
        setHiddenField(element, DisconnectingSlot, disconnectedRootElement);
        return element;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createContextProvider(adapter) {
        var adapterContextToken = getAdapterToken(adapter);
        if (!isUndefined(adapterContextToken)) {
            throw new Error("Adapter already have a context provider.");
        }
        adapterContextToken = guid();
        setAdapterToken(adapter, adapterContextToken);
        var providers = [];
        return function (elm, options) {
            if (ArrayIndexOf.call(providers, elm) !== -1) {
                throw new Error("Adapter was already installed on " + elm + ".");
            }
            providers.push(elm);
            var consumerConnectedCallback = options.consumerConnectedCallback, consumerDisconnectedCallback = options.consumerDisconnectedCallback;
            elm.addEventListener(adapterContextToken, function (evt) {
                var detail = evt.detail;
                var consumer = {
                    provide: function (newContext) {
                        detail(newContext, disconnectCallback);
                    }
                };
                var disconnectCallback = function () {
                    if (!isUndefined(consumerDisconnectedCallback)) {
                        consumerDisconnectedCallback(consumer);
                    }
                };
                consumerConnectedCallback(consumer);
                evt.stopImmediatePropagation();
            });
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     */
    function readonly(obj) {
        return reactiveMembrane.getReadOnlyProxy(obj);
    }
    /* version: 1.6.2 */

    exports.LightningElement = BaseLightningElement;
    exports.api = api;
    exports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;
    exports.createContextProvider = createContextProvider;
    exports.createElement = createElement;
    exports.getComponentConstructor = getComponentConstructor;
    exports.getComponentDef = getComponentDef;
    exports.isComponentConstructor = isComponentConstructor;
    exports.isNodeFromTemplate = isNodeFromTemplate;
    exports.readonly = readonly;
    exports.register = register;
    exports.registerComponent = registerComponent;
    exports.registerDecorators = registerDecorators;
    exports.registerTemplate = registerTemplate;
    exports.sanitizeAttribute = sanitizeAttribute;
    exports.setFeatureFlag = setFeatureFlag;
    exports.setFeatureFlagForTest = setFeatureFlagForTest;
    exports.track = track;
    exports.unwrap = unwrap$1;
    exports.wire = wire;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
